// This file is generated by rust-protobuf 2.4.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Envelope {
    // message fields
    pub cid: ::std::string::String,
    // message oneof groups
    pub message: ::std::option::Option<Envelope_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Envelope_oneof_message {
    channel(Channel),
    channel_join(ChannelJoin),
    channel_leave(ChannelLeave),
    channel_message(super::api::ChannelMessage),
    channel_message_ack(ChannelMessageAck),
    channel_message_send(ChannelMessageSend),
    channel_message_update(ChannelMessageUpdate),
    channel_message_remove(ChannelMessageRemove),
    channel_presence_event(ChannelPresenceEvent),
    error(Error),
    field_match(Match),
    match_create(MatchCreate),
    match_data(MatchData),
    match_data_send(MatchDataSend),
    match_join(MatchJoin),
    match_leave(MatchLeave),
    match_presence_event(MatchPresenceEvent),
    matchmaker_add(MatchmakerAdd),
    matchmaker_matched(MatchmakerMatched),
    matchmaker_remove(MatchmakerRemove),
    matchmaker_ticket(MatchmakerTicket),
    notifications(Notifications),
    rpc(super::api::Rpc),
    status(Status),
    status_follow(StatusFollow),
    status_presence_event(StatusPresenceEvent),
    status_unfollow(StatusUnfollow),
    status_update(StatusUpdate),
    stream_data(StreamData),
    stream_presence_event(StreamPresenceEvent),
}

impl Envelope {
    pub fn new() -> Envelope {
        ::std::default::Default::default()
    }

    // string cid = 1;

    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: ::std::string::String) {
        self.cid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut ::std::string::String {
        &mut self.cid
    }

    // Take field
    pub fn take_cid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cid, ::std::string::String::new())
    }

    pub fn get_cid(&self) -> &str {
        &self.cid
    }

    // .nakama.realtime.Channel channel = 2;

    pub fn clear_channel(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel(Channel::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        if self.has_channel() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel(v)) => v,
                _ => panic!(),
            }
        } else {
            Channel::new()
        }
    }

    pub fn get_channel(&self) -> &Channel {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel(ref v)) => v,
            _ => Channel::default_instance(),
        }
    }

    // .nakama.realtime.ChannelJoin channel_join = 3;

    pub fn clear_channel_join(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_join(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_join(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_join(&mut self, v: ChannelJoin) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_join(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_join(&mut self) -> &mut ChannelJoin {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_join(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_join(ChannelJoin::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_join(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_join(&mut self) -> ChannelJoin {
        if self.has_channel_join() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_join(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelJoin::new()
        }
    }

    pub fn get_channel_join(&self) -> &ChannelJoin {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_join(ref v)) => v,
            _ => ChannelJoin::default_instance(),
        }
    }

    // .nakama.realtime.ChannelLeave channel_leave = 4;

    pub fn clear_channel_leave(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_leave(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_leave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_leave(&mut self, v: ChannelLeave) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_leave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_leave(&mut self) -> &mut ChannelLeave {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_leave(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_leave(ChannelLeave::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_leave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_leave(&mut self) -> ChannelLeave {
        if self.has_channel_leave() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_leave(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelLeave::new()
        }
    }

    pub fn get_channel_leave(&self) -> &ChannelLeave {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_leave(ref v)) => v,
            _ => ChannelLeave::default_instance(),
        }
    }

    // .nakama.api.ChannelMessage channel_message = 5;

    pub fn clear_channel_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_message(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_message(&mut self, v: super::api::ChannelMessage) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_message(&mut self) -> &mut super::api::ChannelMessage {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_message(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message(super::api::ChannelMessage::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_message(&mut self) -> super::api::ChannelMessage {
        if self.has_channel_message() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_message(v)) => v,
                _ => panic!(),
            }
        } else {
            super::api::ChannelMessage::new()
        }
    }

    pub fn get_channel_message(&self) -> &super::api::ChannelMessage {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message(ref v)) => v,
            _ => super::api::ChannelMessage::default_instance(),
        }
    }

    // .nakama.realtime.ChannelMessageAck channel_message_ack = 6;

    pub fn clear_channel_message_ack(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_message_ack(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_message_ack(&mut self, v: ChannelMessageAck) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_message_ack(&mut self) -> &mut ChannelMessageAck {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(ChannelMessageAck::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_message_ack(&mut self) -> ChannelMessageAck {
        if self.has_channel_message_ack() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelMessageAck::new()
        }
    }

    pub fn get_channel_message_ack(&self) -> &ChannelMessageAck {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(ref v)) => v,
            _ => ChannelMessageAck::default_instance(),
        }
    }

    // .nakama.realtime.ChannelMessageSend channel_message_send = 7;

    pub fn clear_channel_message_send(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_message_send(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_message_send(&mut self, v: ChannelMessageSend) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_message_send(&mut self) -> &mut ChannelMessageSend {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(ChannelMessageSend::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_message_send(&mut self) -> ChannelMessageSend {
        if self.has_channel_message_send() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelMessageSend::new()
        }
    }

    pub fn get_channel_message_send(&self) -> &ChannelMessageSend {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(ref v)) => v,
            _ => ChannelMessageSend::default_instance(),
        }
    }

    // .nakama.realtime.ChannelMessageUpdate channel_message_update = 8;

    pub fn clear_channel_message_update(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_message_update(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_message_update(&mut self, v: ChannelMessageUpdate) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_message_update(&mut self) -> &mut ChannelMessageUpdate {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(ChannelMessageUpdate::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_message_update(&mut self) -> ChannelMessageUpdate {
        if self.has_channel_message_update() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelMessageUpdate::new()
        }
    }

    pub fn get_channel_message_update(&self) -> &ChannelMessageUpdate {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(ref v)) => v,
            _ => ChannelMessageUpdate::default_instance(),
        }
    }

    // .nakama.realtime.ChannelMessageRemove channel_message_remove = 9;

    pub fn clear_channel_message_remove(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_message_remove(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_message_remove(&mut self, v: ChannelMessageRemove) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_message_remove(&mut self) -> &mut ChannelMessageRemove {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(ChannelMessageRemove::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_message_remove(&mut self) -> ChannelMessageRemove {
        if self.has_channel_message_remove() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelMessageRemove::new()
        }
    }

    pub fn get_channel_message_remove(&self) -> &ChannelMessageRemove {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(ref v)) => v,
            _ => ChannelMessageRemove::default_instance(),
        }
    }

    // .nakama.realtime.ChannelPresenceEvent channel_presence_event = 10;

    pub fn clear_channel_presence_event(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_channel_presence_event(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_channel_presence_event(&mut self, v: ChannelPresenceEvent) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_channel_presence_event(&mut self) -> &mut ChannelPresenceEvent {
        if let ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(ChannelPresenceEvent::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_channel_presence_event(&mut self) -> ChannelPresenceEvent {
        if self.has_channel_presence_event() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPresenceEvent::new()
        }
    }

    pub fn get_channel_presence_event(&self) -> &ChannelPresenceEvent {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(ref v)) => v,
            _ => ChannelPresenceEvent::default_instance(),
        }
    }

    // .nakama.realtime.Error error = 11;

    pub fn clear_error(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut Error {
        if let ::std::option::Option::Some(Envelope_oneof_message::error(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::error(Error::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        if self.has_error() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::error(v)) => v,
                _ => panic!(),
            }
        } else {
            Error::new()
        }
    }

    pub fn get_error(&self) -> &Error {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::error(ref v)) => v,
            _ => Error::default_instance(),
        }
    }

    // .nakama.realtime.Match match = 12;

    pub fn clear_field_match(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_field_match(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::field_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: Match) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::field_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_match(&mut self) -> &mut Match {
        if let ::std::option::Option::Some(Envelope_oneof_message::field_match(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::field_match(Match::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::field_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_match(&mut self) -> Match {
        if self.has_field_match() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::field_match(v)) => v,
                _ => panic!(),
            }
        } else {
            Match::new()
        }
    }

    pub fn get_field_match(&self) -> &Match {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::field_match(ref v)) => v,
            _ => Match::default_instance(),
        }
    }

    // .nakama.realtime.MatchCreate match_create = 13;

    pub fn clear_match_create(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_create(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_create(&mut self, v: MatchCreate) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_create(&mut self) -> &mut MatchCreate {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_create(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_create(MatchCreate::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_create(&mut self) -> MatchCreate {
        if self.has_match_create() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_create(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchCreate::new()
        }
    }

    pub fn get_match_create(&self) -> &MatchCreate {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_create(ref v)) => v,
            _ => MatchCreate::default_instance(),
        }
    }

    // .nakama.realtime.MatchData match_data = 14;

    pub fn clear_match_data(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_data(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_data(&mut self, v: MatchData) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_data(&mut self) -> &mut MatchData {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_data(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data(MatchData::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_data(&mut self) -> MatchData {
        if self.has_match_data() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_data(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchData::new()
        }
    }

    pub fn get_match_data(&self) -> &MatchData {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data(ref v)) => v,
            _ => MatchData::default_instance(),
        }
    }

    // .nakama.realtime.MatchDataSend match_data_send = 15;

    pub fn clear_match_data_send(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_data_send(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data_send(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_data_send(&mut self, v: MatchDataSend) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data_send(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_data_send(&mut self) -> &mut MatchDataSend {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_data_send(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data_send(MatchDataSend::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data_send(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_data_send(&mut self) -> MatchDataSend {
        if self.has_match_data_send() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_data_send(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchDataSend::new()
        }
    }

    pub fn get_match_data_send(&self) -> &MatchDataSend {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_data_send(ref v)) => v,
            _ => MatchDataSend::default_instance(),
        }
    }

    // .nakama.realtime.MatchJoin match_join = 16;

    pub fn clear_match_join(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_join(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_join(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_join(&mut self, v: MatchJoin) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_join(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_join(&mut self) -> &mut MatchJoin {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_join(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_join(MatchJoin::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_join(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_join(&mut self) -> MatchJoin {
        if self.has_match_join() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_join(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchJoin::new()
        }
    }

    pub fn get_match_join(&self) -> &MatchJoin {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_join(ref v)) => v,
            _ => MatchJoin::default_instance(),
        }
    }

    // .nakama.realtime.MatchLeave match_leave = 17;

    pub fn clear_match_leave(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_leave(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_leave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_leave(&mut self, v: MatchLeave) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_leave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_leave(&mut self) -> &mut MatchLeave {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_leave(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_leave(MatchLeave::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_leave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_leave(&mut self) -> MatchLeave {
        if self.has_match_leave() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_leave(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchLeave::new()
        }
    }

    pub fn get_match_leave(&self) -> &MatchLeave {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_leave(ref v)) => v,
            _ => MatchLeave::default_instance(),
        }
    }

    // .nakama.realtime.MatchPresenceEvent match_presence_event = 18;

    pub fn clear_match_presence_event(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_match_presence_event(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_presence_event(&mut self, v: MatchPresenceEvent) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_presence_event(&mut self) -> &mut MatchPresenceEvent {
        if let ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(MatchPresenceEvent::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_presence_event(&mut self) -> MatchPresenceEvent {
        if self.has_match_presence_event() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchPresenceEvent::new()
        }
    }

    pub fn get_match_presence_event(&self) -> &MatchPresenceEvent {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(ref v)) => v,
            _ => MatchPresenceEvent::default_instance(),
        }
    }

    // .nakama.realtime.MatchmakerAdd matchmaker_add = 19;

    pub fn clear_matchmaker_add(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_matchmaker_add(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matchmaker_add(&mut self, v: MatchmakerAdd) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matchmaker_add(&mut self) -> &mut MatchmakerAdd {
        if let ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(MatchmakerAdd::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matchmaker_add(&mut self) -> MatchmakerAdd {
        if self.has_matchmaker_add() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchmakerAdd::new()
        }
    }

    pub fn get_matchmaker_add(&self) -> &MatchmakerAdd {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(ref v)) => v,
            _ => MatchmakerAdd::default_instance(),
        }
    }

    // .nakama.realtime.MatchmakerMatched matchmaker_matched = 20;

    pub fn clear_matchmaker_matched(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_matchmaker_matched(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matchmaker_matched(&mut self, v: MatchmakerMatched) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matchmaker_matched(&mut self) -> &mut MatchmakerMatched {
        if let ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(MatchmakerMatched::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matchmaker_matched(&mut self) -> MatchmakerMatched {
        if self.has_matchmaker_matched() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchmakerMatched::new()
        }
    }

    pub fn get_matchmaker_matched(&self) -> &MatchmakerMatched {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(ref v)) => v,
            _ => MatchmakerMatched::default_instance(),
        }
    }

    // .nakama.realtime.MatchmakerRemove matchmaker_remove = 21;

    pub fn clear_matchmaker_remove(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_matchmaker_remove(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matchmaker_remove(&mut self, v: MatchmakerRemove) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matchmaker_remove(&mut self) -> &mut MatchmakerRemove {
        if let ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(MatchmakerRemove::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matchmaker_remove(&mut self) -> MatchmakerRemove {
        if self.has_matchmaker_remove() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchmakerRemove::new()
        }
    }

    pub fn get_matchmaker_remove(&self) -> &MatchmakerRemove {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(ref v)) => v,
            _ => MatchmakerRemove::default_instance(),
        }
    }

    // .nakama.realtime.MatchmakerTicket matchmaker_ticket = 22;

    pub fn clear_matchmaker_ticket(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_matchmaker_ticket(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_matchmaker_ticket(&mut self, v: MatchmakerTicket) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(v))
    }

    // Mutable pointer to the field.
    pub fn mut_matchmaker_ticket(&mut self) -> &mut MatchmakerTicket {
        if let ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(MatchmakerTicket::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_matchmaker_ticket(&mut self) -> MatchmakerTicket {
        if self.has_matchmaker_ticket() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(v)) => v,
                _ => panic!(),
            }
        } else {
            MatchmakerTicket::new()
        }
    }

    pub fn get_matchmaker_ticket(&self) -> &MatchmakerTicket {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(ref v)) => v,
            _ => MatchmakerTicket::default_instance(),
        }
    }

    // .nakama.realtime.Notifications notifications = 23;

    pub fn clear_notifications(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_notifications(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::notifications(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: Notifications) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::notifications(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut Notifications {
        if let ::std::option::Option::Some(Envelope_oneof_message::notifications(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::notifications(Notifications::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::notifications(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notifications(&mut self) -> Notifications {
        if self.has_notifications() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::notifications(v)) => v,
                _ => panic!(),
            }
        } else {
            Notifications::new()
        }
    }

    pub fn get_notifications(&self) -> &Notifications {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::notifications(ref v)) => v,
            _ => Notifications::default_instance(),
        }
    }

    // .nakama.api.Rpc rpc = 24;

    pub fn clear_rpc(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_rpc(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::rpc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpc(&mut self, v: super::api::Rpc) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::rpc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpc(&mut self) -> &mut super::api::Rpc {
        if let ::std::option::Option::Some(Envelope_oneof_message::rpc(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::rpc(super::api::Rpc::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::rpc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpc(&mut self) -> super::api::Rpc {
        if self.has_rpc() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::rpc(v)) => v,
                _ => panic!(),
            }
        } else {
            super::api::Rpc::new()
        }
    }

    pub fn get_rpc(&self) -> &super::api::Rpc {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::rpc(ref v)) => v,
            _ => super::api::Rpc::default_instance(),
        }
    }

    // .nakama.realtime.Status status = 25;

    pub fn clear_status(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut Status {
        if let ::std::option::Option::Some(Envelope_oneof_message::status(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::status(Status::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status(&mut self) -> Status {
        if self.has_status() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::status(v)) => v,
                _ => panic!(),
            }
        } else {
            Status::new()
        }
    }

    pub fn get_status(&self) -> &Status {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status(ref v)) => v,
            _ => Status::default_instance(),
        }
    }

    // .nakama.realtime.StatusFollow status_follow = 26;

    pub fn clear_status_follow(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_status_follow(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_follow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_follow(&mut self, v: StatusFollow) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::status_follow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_follow(&mut self) -> &mut StatusFollow {
        if let ::std::option::Option::Some(Envelope_oneof_message::status_follow(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::status_follow(StatusFollow::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_follow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_follow(&mut self) -> StatusFollow {
        if self.has_status_follow() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::status_follow(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusFollow::new()
        }
    }

    pub fn get_status_follow(&self) -> &StatusFollow {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_follow(ref v)) => v,
            _ => StatusFollow::default_instance(),
        }
    }

    // .nakama.realtime.StatusPresenceEvent status_presence_event = 27;

    pub fn clear_status_presence_event(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_status_presence_event(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_presence_event(&mut self, v: StatusPresenceEvent) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_presence_event(&mut self) -> &mut StatusPresenceEvent {
        if let ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(StatusPresenceEvent::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_presence_event(&mut self) -> StatusPresenceEvent {
        if self.has_status_presence_event() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusPresenceEvent::new()
        }
    }

    pub fn get_status_presence_event(&self) -> &StatusPresenceEvent {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(ref v)) => v,
            _ => StatusPresenceEvent::default_instance(),
        }
    }

    // .nakama.realtime.StatusUnfollow status_unfollow = 28;

    pub fn clear_status_unfollow(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_status_unfollow(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_unfollow(&mut self, v: StatusUnfollow) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_unfollow(&mut self) -> &mut StatusUnfollow {
        if let ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(StatusUnfollow::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_unfollow(&mut self) -> StatusUnfollow {
        if self.has_status_unfollow() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusUnfollow::new()
        }
    }

    pub fn get_status_unfollow(&self) -> &StatusUnfollow {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(ref v)) => v,
            _ => StatusUnfollow::default_instance(),
        }
    }

    // .nakama.realtime.StatusUpdate status_update = 29;

    pub fn clear_status_update(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_status_update(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_update(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status_update(&mut self, v: StatusUpdate) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::status_update(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status_update(&mut self) -> &mut StatusUpdate {
        if let ::std::option::Option::Some(Envelope_oneof_message::status_update(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::status_update(StatusUpdate::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_update(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status_update(&mut self) -> StatusUpdate {
        if self.has_status_update() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::status_update(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusUpdate::new()
        }
    }

    pub fn get_status_update(&self) -> &StatusUpdate {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::status_update(ref v)) => v,
            _ => StatusUpdate::default_instance(),
        }
    }

    // .nakama.realtime.StreamData stream_data = 30;

    pub fn clear_stream_data(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_stream_data(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream_data(&mut self, v: StreamData) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream_data(&mut self) -> &mut StreamData {
        if let ::std::option::Option::Some(Envelope_oneof_message::stream_data(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_data(StreamData::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream_data(&mut self) -> StreamData {
        if self.has_stream_data() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::stream_data(v)) => v,
                _ => panic!(),
            }
        } else {
            StreamData::new()
        }
    }

    pub fn get_stream_data(&self) -> &StreamData {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_data(ref v)) => v,
            _ => StreamData::default_instance(),
        }
    }

    // .nakama.realtime.StreamPresenceEvent stream_presence_event = 31;

    pub fn clear_stream_presence_event(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_stream_presence_event(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream_presence_event(&mut self, v: StreamPresenceEvent) {
        self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream_presence_event(&mut self) -> &mut StreamPresenceEvent {
        if let ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(StreamPresenceEvent::new()));
        }
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream_presence_event(&mut self) -> StreamPresenceEvent {
        if self.has_stream_presence_event() {
            match self.message.take() {
                ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(v)) => v,
                _ => panic!(),
            }
        } else {
            StreamPresenceEvent::new()
        }
    }

    pub fn get_stream_presence_event(&self) -> &StreamPresenceEvent {
        match self.message {
            ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(ref v)) => v,
            _ => StreamPresenceEvent::default_instance(),
        }
    }
}

impl ::protobuf::Message for Envelope {
    fn is_initialized(&self) -> bool {
        if let Some(Envelope_oneof_message::channel(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_join(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_leave(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_message(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_message_ack(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_message_send(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_message_update(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_message_remove(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::channel_presence_event(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::error(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::field_match(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_create(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_data(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_data_send(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_join(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_leave(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::match_presence_event(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::matchmaker_add(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::matchmaker_matched(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::matchmaker_remove(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::matchmaker_ticket(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::notifications(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::rpc(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::status(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::status_follow(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::status_presence_event(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::status_unfollow(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::status_update(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::stream_data(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Envelope_oneof_message::stream_presence_event(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_join(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_leave(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_ack(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_send(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_update(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_message_remove(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::channel_presence_event(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::error(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::field_match(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_create(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_data_send(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_join(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_leave(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::match_presence_event(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_add(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_matched(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_remove(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::matchmaker_ticket(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::notifications(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::rpc(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::status(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::status_follow(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::status_presence_event(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::status_unfollow(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::status_update(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_data(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(Envelope_oneof_message::stream_presence_event(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cid);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Envelope_oneof_message::channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_join(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_leave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_message_ack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_message_send(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_message_update(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_message_remove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::channel_presence_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::field_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_data_send(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_join(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_leave(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::match_presence_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::matchmaker_add(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::matchmaker_matched(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::matchmaker_remove(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::matchmaker_ticket(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::notifications(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::rpc(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::status(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::status_follow(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::status_presence_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::status_unfollow(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::status_update(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::stream_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Envelope_oneof_message::stream_presence_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.cid.is_empty() {
            os.write_string(1, &self.cid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &Envelope_oneof_message::channel(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_join(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_leave(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_message(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_message_ack(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_message_send(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_message_update(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_message_remove(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::channel_presence_event(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::error(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::field_match(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_create(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_data(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_data_send(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_join(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_leave(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::match_presence_event(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::matchmaker_add(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::matchmaker_matched(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::matchmaker_remove(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::matchmaker_ticket(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::notifications(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::rpc(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::status(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::status_follow(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::status_presence_event(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::status_unfollow(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::status_update(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::stream_data(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Envelope_oneof_message::stream_presence_event(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Envelope {
        Envelope::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cid",
                    |m: &Envelope| { &m.cid },
                    |m: &mut Envelope| { &mut m.cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Channel>(
                    "channel",
                    Envelope::has_channel,
                    Envelope::get_channel,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelJoin>(
                    "channel_join",
                    Envelope::has_channel_join,
                    Envelope::get_channel_join,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelLeave>(
                    "channel_leave",
                    Envelope::has_channel_leave,
                    Envelope::get_channel_leave,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::api::ChannelMessage>(
                    "channel_message",
                    Envelope::has_channel_message,
                    Envelope::get_channel_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelMessageAck>(
                    "channel_message_ack",
                    Envelope::has_channel_message_ack,
                    Envelope::get_channel_message_ack,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelMessageSend>(
                    "channel_message_send",
                    Envelope::has_channel_message_send,
                    Envelope::get_channel_message_send,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelMessageUpdate>(
                    "channel_message_update",
                    Envelope::has_channel_message_update,
                    Envelope::get_channel_message_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelMessageRemove>(
                    "channel_message_remove",
                    Envelope::has_channel_message_remove,
                    Envelope::get_channel_message_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPresenceEvent>(
                    "channel_presence_event",
                    Envelope::has_channel_presence_event,
                    Envelope::get_channel_presence_event,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Error>(
                    "error",
                    Envelope::has_error,
                    Envelope::get_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Match>(
                    "match",
                    Envelope::has_field_match,
                    Envelope::get_field_match,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchCreate>(
                    "match_create",
                    Envelope::has_match_create,
                    Envelope::get_match_create,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchData>(
                    "match_data",
                    Envelope::has_match_data,
                    Envelope::get_match_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchDataSend>(
                    "match_data_send",
                    Envelope::has_match_data_send,
                    Envelope::get_match_data_send,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchJoin>(
                    "match_join",
                    Envelope::has_match_join,
                    Envelope::get_match_join,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchLeave>(
                    "match_leave",
                    Envelope::has_match_leave,
                    Envelope::get_match_leave,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchPresenceEvent>(
                    "match_presence_event",
                    Envelope::has_match_presence_event,
                    Envelope::get_match_presence_event,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchmakerAdd>(
                    "matchmaker_add",
                    Envelope::has_matchmaker_add,
                    Envelope::get_matchmaker_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchmakerMatched>(
                    "matchmaker_matched",
                    Envelope::has_matchmaker_matched,
                    Envelope::get_matchmaker_matched,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchmakerRemove>(
                    "matchmaker_remove",
                    Envelope::has_matchmaker_remove,
                    Envelope::get_matchmaker_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MatchmakerTicket>(
                    "matchmaker_ticket",
                    Envelope::has_matchmaker_ticket,
                    Envelope::get_matchmaker_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Notifications>(
                    "notifications",
                    Envelope::has_notifications,
                    Envelope::get_notifications,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::api::Rpc>(
                    "rpc",
                    Envelope::has_rpc,
                    Envelope::get_rpc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Status>(
                    "status",
                    Envelope::has_status,
                    Envelope::get_status,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StatusFollow>(
                    "status_follow",
                    Envelope::has_status_follow,
                    Envelope::get_status_follow,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StatusPresenceEvent>(
                    "status_presence_event",
                    Envelope::has_status_presence_event,
                    Envelope::get_status_presence_event,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StatusUnfollow>(
                    "status_unfollow",
                    Envelope::has_status_unfollow,
                    Envelope::get_status_unfollow,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StatusUpdate>(
                    "status_update",
                    Envelope::has_status_update,
                    Envelope::get_status_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StreamData>(
                    "stream_data",
                    Envelope::has_stream_data,
                    Envelope::get_stream_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StreamPresenceEvent>(
                    "stream_presence_event",
                    Envelope::has_stream_presence_event,
                    Envelope::get_stream_presence_event,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Envelope>(
                    "Envelope",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Envelope {
        static mut instance: ::protobuf::lazy::Lazy<Envelope> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Envelope,
        };
        unsafe {
            instance.get(Envelope::new)
        }
    }
}

impl ::protobuf::Clear for Envelope {
    fn clear(&mut self) {
        self.clear_cid();
        self.clear_channel();
        self.clear_channel_join();
        self.clear_channel_leave();
        self.clear_channel_message();
        self.clear_channel_message_ack();
        self.clear_channel_message_send();
        self.clear_channel_message_update();
        self.clear_channel_message_remove();
        self.clear_channel_presence_event();
        self.clear_error();
        self.clear_field_match();
        self.clear_match_create();
        self.clear_match_data();
        self.clear_match_data_send();
        self.clear_match_join();
        self.clear_match_leave();
        self.clear_match_presence_event();
        self.clear_matchmaker_add();
        self.clear_matchmaker_matched();
        self.clear_matchmaker_remove();
        self.clear_matchmaker_ticket();
        self.clear_notifications();
        self.clear_rpc();
        self.clear_status();
        self.clear_status_follow();
        self.clear_status_presence_event();
        self.clear_status_unfollow();
        self.clear_status_update();
        self.clear_stream_data();
        self.clear_stream_presence_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Envelope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Envelope {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub id: ::std::string::String,
    pub presences: ::protobuf::RepeatedField<UserPresence>,
    pub field_self: ::protobuf::SingularPtrField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // repeated .nakama.realtime.UserPresence presences = 2;

    pub fn clear_presences(&mut self) {
        self.presences.clear();
    }

    // Param is passed by value, moved
    pub fn set_presences(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.presences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_presences(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.presences
    }

    // Take field
    pub fn take_presences(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.presences, ::protobuf::RepeatedField::new())
    }

    pub fn get_presences(&self) -> &[UserPresence] {
        &self.presences
    }

    // .nakama.realtime.UserPresence self = 3;

    pub fn clear_field_self(&mut self) {
        self.field_self.clear();
    }

    pub fn has_field_self(&self) -> bool {
        self.field_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: UserPresence) {
        self.field_self = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_self(&mut self) -> &mut UserPresence {
        if self.field_self.is_none() {
            self.field_self.set_default();
        }
        self.field_self.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_self(&mut self) -> UserPresence {
        self.field_self.take().unwrap_or_else(|| UserPresence::new())
    }

    pub fn get_field_self(&self) -> &UserPresence {
        self.field_self.as_ref().unwrap_or_else(|| UserPresence::default_instance())
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.presences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_self {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.presences)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_self)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.presences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.presences {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Channel| { &m.id },
                    |m: &mut Channel| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presences",
                    |m: &Channel| { &m.presences },
                    |m: &mut Channel| { &mut m.presences },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "self",
                    |m: &Channel| { &m.field_self },
                    |m: &mut Channel| { &mut m.field_self },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Channel>(
                    "Channel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Channel {
        static mut instance: ::protobuf::lazy::Lazy<Channel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Channel,
        };
        unsafe {
            instance.get(Channel::new)
        }
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_presences();
        self.clear_field_self();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelJoin {
    // message fields
    pub target: ::std::string::String,
    pub field_type: i32,
    pub persistence: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub hidden: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelJoin {
    pub fn new() -> ChannelJoin {
        ::std::default::Default::default()
    }

    // string target = 1;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        &mut self.target
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target, ::std::string::String::new())
    }

    pub fn get_target(&self) -> &str {
        &self.target
    }

    // int32 type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type
    }

    // .google.protobuf.BoolValue persistence = 3;

    pub fn clear_persistence(&mut self) {
        self.persistence.clear();
    }

    pub fn has_persistence(&self) -> bool {
        self.persistence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.persistence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistence(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.persistence.is_none() {
            self.persistence.set_default();
        }
        self.persistence.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistence(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.persistence.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_persistence(&self) -> &::protobuf::well_known_types::BoolValue {
        self.persistence.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // .google.protobuf.BoolValue hidden = 4;

    pub fn clear_hidden(&mut self) {
        self.hidden.clear();
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.hidden = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hidden(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.hidden.is_none() {
            self.hidden.set_default();
        }
        self.hidden.as_mut().unwrap()
    }

    // Take field
    pub fn take_hidden(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.hidden.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_hidden(&self) -> &::protobuf::well_known_types::BoolValue {
        self.hidden.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for ChannelJoin {
    fn is_initialized(&self) -> bool {
        for v in &self.persistence {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hidden {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistence)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hidden)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.target.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.target);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persistence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hidden.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.target.is_empty() {
            os.write_string(1, &self.target)?;
        }
        if self.field_type != 0 {
            os.write_int32(2, self.field_type)?;
        }
        if let Some(ref v) = self.persistence.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hidden.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelJoin {
        ChannelJoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    |m: &ChannelJoin| { &m.target },
                    |m: &mut ChannelJoin| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    |m: &ChannelJoin| { &m.field_type },
                    |m: &mut ChannelJoin| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "persistence",
                    |m: &ChannelJoin| { &m.persistence },
                    |m: &mut ChannelJoin| { &mut m.persistence },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "hidden",
                    |m: &ChannelJoin| { &m.hidden },
                    |m: &mut ChannelJoin| { &mut m.hidden },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelJoin>(
                    "ChannelJoin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelJoin {
        static mut instance: ::protobuf::lazy::Lazy<ChannelJoin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelJoin,
        };
        unsafe {
            instance.get(ChannelJoin::new)
        }
    }
}

impl ::protobuf::Clear for ChannelJoin {
    fn clear(&mut self) {
        self.clear_target();
        self.clear_field_type();
        self.clear_persistence();
        self.clear_hidden();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelJoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelJoin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChannelJoin_Type {
    TYPE_UNSPECIFIED = 0,
    ROOM = 1,
    DIRECT_MESSAGE = 2,
    GROUP = 3,
}

impl ::protobuf::ProtobufEnum for ChannelJoin_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelJoin_Type> {
        match value {
            0 => ::std::option::Option::Some(ChannelJoin_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ChannelJoin_Type::ROOM),
            2 => ::std::option::Option::Some(ChannelJoin_Type::DIRECT_MESSAGE),
            3 => ::std::option::Option::Some(ChannelJoin_Type::GROUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelJoin_Type] = &[
            ChannelJoin_Type::TYPE_UNSPECIFIED,
            ChannelJoin_Type::ROOM,
            ChannelJoin_Type::DIRECT_MESSAGE,
            ChannelJoin_Type::GROUP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChannelJoin_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChannelJoin_Type {
}

impl ::std::default::Default for ChannelJoin_Type {
    fn default() -> Self {
        ChannelJoin_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelJoin_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelLeave {
    // message fields
    pub channel_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelLeave {
    pub fn new() -> ChannelLeave {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
}

impl ::protobuf::Message for ChannelLeave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelLeave {
        ChannelLeave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelLeave| { &m.channel_id },
                    |m: &mut ChannelLeave| { &mut m.channel_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelLeave>(
                    "ChannelLeave",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelLeave {
        static mut instance: ::protobuf::lazy::Lazy<ChannelLeave> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelLeave,
        };
        unsafe {
            instance.get(ChannelLeave::new)
        }
    }
}

impl ::protobuf::Clear for ChannelLeave {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelLeave {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessageAck {
    // message fields
    pub channel_id: ::std::string::String,
    pub message_id: ::std::string::String,
    pub code: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub username: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub persistent: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessageAck {
    pub fn new() -> ChannelMessageAck {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // string message_id = 2;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }

    // .google.protobuf.Int32Value code = 3;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.code.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_code(&self) -> &::protobuf::well_known_types::Int32Value {
        self.code.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string username = 4;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // .google.protobuf.Timestamp create_time = 5;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 6;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.BoolValue persistent = 7;

    pub fn clear_persistent(&mut self) {
        self.persistent.clear();
    }

    pub fn has_persistent(&self) -> bool {
        self.persistent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.persistent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistent(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.persistent.is_none() {
            self.persistent.set_default();
        }
        self.persistent.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistent(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.persistent.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_persistent(&self) -> &::protobuf::well_known_types::BoolValue {
        self.persistent.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for ChannelMessageAck {
    fn is_initialized(&self) -> bool {
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.persistent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message_id);
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.username);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.message_id.is_empty() {
            os.write_string(2, &self.message_id)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(4, &self.username)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistent.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessageAck {
        ChannelMessageAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelMessageAck| { &m.channel_id },
                    |m: &mut ChannelMessageAck| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &ChannelMessageAck| { &m.message_id },
                    |m: &mut ChannelMessageAck| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "code",
                    |m: &ChannelMessageAck| { &m.code },
                    |m: &mut ChannelMessageAck| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &ChannelMessageAck| { &m.username },
                    |m: &mut ChannelMessageAck| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &ChannelMessageAck| { &m.create_time },
                    |m: &mut ChannelMessageAck| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &ChannelMessageAck| { &m.update_time },
                    |m: &mut ChannelMessageAck| { &mut m.update_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "persistent",
                    |m: &ChannelMessageAck| { &m.persistent },
                    |m: &mut ChannelMessageAck| { &mut m.persistent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessageAck>(
                    "ChannelMessageAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessageAck {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessageAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessageAck,
        };
        unsafe {
            instance.get(ChannelMessageAck::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessageAck {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_message_id();
        self.clear_code();
        self.clear_username();
        self.clear_create_time();
        self.clear_update_time();
        self.clear_persistent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessageAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessageAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessageSend {
    // message fields
    pub channel_id: ::std::string::String,
    pub content: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessageSend {
    pub fn new() -> ChannelMessageSend {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // string content = 2;

    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    pub fn get_content(&self) -> &str {
        &self.content
    }
}

impl ::protobuf::Message for ChannelMessageSend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessageSend {
        ChannelMessageSend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelMessageSend| { &m.channel_id },
                    |m: &mut ChannelMessageSend| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &ChannelMessageSend| { &m.content },
                    |m: &mut ChannelMessageSend| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessageSend>(
                    "ChannelMessageSend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessageSend {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessageSend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessageSend,
        };
        unsafe {
            instance.get(ChannelMessageSend::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessageSend {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_content();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessageSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessageSend {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessageUpdate {
    // message fields
    pub channel_id: ::std::string::String,
    pub message_id: ::std::string::String,
    pub content: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessageUpdate {
    pub fn new() -> ChannelMessageUpdate {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // string message_id = 2;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }

    // string content = 3;

    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    pub fn get_content(&self) -> &str {
        &self.content
    }
}

impl ::protobuf::Message for ChannelMessageUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message_id);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.message_id.is_empty() {
            os.write_string(2, &self.message_id)?;
        }
        if !self.content.is_empty() {
            os.write_string(3, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessageUpdate {
        ChannelMessageUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelMessageUpdate| { &m.channel_id },
                    |m: &mut ChannelMessageUpdate| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &ChannelMessageUpdate| { &m.message_id },
                    |m: &mut ChannelMessageUpdate| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &ChannelMessageUpdate| { &m.content },
                    |m: &mut ChannelMessageUpdate| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessageUpdate>(
                    "ChannelMessageUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessageUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessageUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessageUpdate,
        };
        unsafe {
            instance.get(ChannelMessageUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessageUpdate {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_message_id();
        self.clear_content();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessageUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessageUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessageRemove {
    // message fields
    pub channel_id: ::std::string::String,
    pub message_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessageRemove {
    pub fn new() -> ChannelMessageRemove {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // string message_id = 2;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
}

impl ::protobuf::Message for ChannelMessageRemove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.message_id.is_empty() {
            os.write_string(2, &self.message_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessageRemove {
        ChannelMessageRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelMessageRemove| { &m.channel_id },
                    |m: &mut ChannelMessageRemove| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &ChannelMessageRemove| { &m.message_id },
                    |m: &mut ChannelMessageRemove| { &mut m.message_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessageRemove>(
                    "ChannelMessageRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessageRemove {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessageRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessageRemove,
        };
        unsafe {
            instance.get(ChannelMessageRemove::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessageRemove {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_message_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessageRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessageRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelPresenceEvent {
    // message fields
    pub channel_id: ::std::string::String,
    pub joins: ::protobuf::RepeatedField<UserPresence>,
    pub leaves: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelPresenceEvent {
    pub fn new() -> ChannelPresenceEvent {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // repeated .nakama.realtime.UserPresence joins = 2;

    pub fn clear_joins(&mut self) {
        self.joins.clear();
    }

    // Param is passed by value, moved
    pub fn set_joins(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.joins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_joins(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.joins
    }

    // Take field
    pub fn take_joins(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.joins, ::protobuf::RepeatedField::new())
    }

    pub fn get_joins(&self) -> &[UserPresence] {
        &self.joins
    }

    // repeated .nakama.realtime.UserPresence leaves = 3;

    pub fn clear_leaves(&mut self) {
        self.leaves.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaves(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.leaves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaves(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.leaves
    }

    // Take field
    pub fn take_leaves(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.leaves, ::protobuf::RepeatedField::new())
    }

    pub fn get_leaves(&self) -> &[UserPresence] {
        &self.leaves
    }
}

impl ::protobuf::Message for ChannelPresenceEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.joins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leaves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.joins)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leaves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        for value in &self.joins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.leaves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        for v in &self.joins {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.leaves {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelPresenceEvent {
        ChannelPresenceEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelPresenceEvent| { &m.channel_id },
                    |m: &mut ChannelPresenceEvent| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "joins",
                    |m: &ChannelPresenceEvent| { &m.joins },
                    |m: &mut ChannelPresenceEvent| { &mut m.joins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "leaves",
                    |m: &ChannelPresenceEvent| { &m.leaves },
                    |m: &mut ChannelPresenceEvent| { &mut m.leaves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelPresenceEvent>(
                    "ChannelPresenceEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelPresenceEvent {
        static mut instance: ::protobuf::lazy::Lazy<ChannelPresenceEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelPresenceEvent,
        };
        unsafe {
            instance.get(ChannelPresenceEvent::new)
        }
    }
}

impl ::protobuf::Clear for ChannelPresenceEvent {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_joins();
        self.clear_leaves();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelPresenceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelPresenceEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    pub context: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // int32 code = 1;

    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    pub fn get_code(&self) -> i32 {
        self.code
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }

    // repeated .nakama.realtime.Error.ContextEntry context = 3;

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.context = v;
    }

    // Mutable pointer to the field.
    pub fn mut_context(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.context
    }

    // Take field
    pub fn take_context(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.context, ::std::collections::HashMap::new())
    }

    pub fn get_context(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.context
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.context);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.context, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &Error| { &m.code },
                    |m: &mut Error| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &Error| { &m.message },
                    |m: &mut Error| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "context",
                    |m: &Error| { &m.context },
                    |m: &mut Error| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_message();
        self.clear_context();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Error_Code {
    RUNTIME_EXCEPTION = 0,
    UNRECOGNIZED_PAYLOAD = 1,
    MISSING_PAYLOAD = 2,
    BAD_INPUT = 3,
    MATCH_NOT_FOUND = 4,
    MATCH_JOIN_REJECTED = 5,
    RUNTIME_FUNCTION_NOT_FOUND = 6,
    RUNTIME_FUNCTION_EXCEPTION = 7,
}

impl ::protobuf::ProtobufEnum for Error_Code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Error_Code> {
        match value {
            0 => ::std::option::Option::Some(Error_Code::RUNTIME_EXCEPTION),
            1 => ::std::option::Option::Some(Error_Code::UNRECOGNIZED_PAYLOAD),
            2 => ::std::option::Option::Some(Error_Code::MISSING_PAYLOAD),
            3 => ::std::option::Option::Some(Error_Code::BAD_INPUT),
            4 => ::std::option::Option::Some(Error_Code::MATCH_NOT_FOUND),
            5 => ::std::option::Option::Some(Error_Code::MATCH_JOIN_REJECTED),
            6 => ::std::option::Option::Some(Error_Code::RUNTIME_FUNCTION_NOT_FOUND),
            7 => ::std::option::Option::Some(Error_Code::RUNTIME_FUNCTION_EXCEPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Error_Code] = &[
            Error_Code::RUNTIME_EXCEPTION,
            Error_Code::UNRECOGNIZED_PAYLOAD,
            Error_Code::MISSING_PAYLOAD,
            Error_Code::BAD_INPUT,
            Error_Code::MATCH_NOT_FOUND,
            Error_Code::MATCH_JOIN_REJECTED,
            Error_Code::RUNTIME_FUNCTION_NOT_FOUND,
            Error_Code::RUNTIME_FUNCTION_EXCEPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Error_Code", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Error_Code {
}

impl ::std::default::Default for Error_Code {
    fn default() -> Self {
        Error_Code::RUNTIME_EXCEPTION
    }
}

impl ::protobuf::reflect::ProtobufValue for Error_Code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Match {
    // message fields
    pub match_id: ::std::string::String,
    pub authoritative: bool,
    pub label: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub size: i32,
    pub presences: ::protobuf::RepeatedField<UserPresence>,
    pub field_self: ::protobuf::SingularPtrField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Match {
    pub fn new() -> Match {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }

    // bool authoritative = 2;

    pub fn clear_authoritative(&mut self) {
        self.authoritative = false;
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = v;
    }

    pub fn get_authoritative(&self) -> bool {
        self.authoritative
    }

    // .google.protobuf.StringValue label = 3;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.label.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_label(&self) -> &::protobuf::well_known_types::StringValue {
        self.label.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // int32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }

    pub fn get_size(&self) -> i32 {
        self.size
    }

    // repeated .nakama.realtime.UserPresence presences = 5;

    pub fn clear_presences(&mut self) {
        self.presences.clear();
    }

    // Param is passed by value, moved
    pub fn set_presences(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.presences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_presences(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.presences
    }

    // Take field
    pub fn take_presences(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.presences, ::protobuf::RepeatedField::new())
    }

    pub fn get_presences(&self) -> &[UserPresence] {
        &self.presences
    }

    // .nakama.realtime.UserPresence self = 6;

    pub fn clear_field_self(&mut self) {
        self.field_self.clear();
    }

    pub fn has_field_self(&self) -> bool {
        self.field_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: UserPresence) {
        self.field_self = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_self(&mut self) -> &mut UserPresence {
        if self.field_self.is_none() {
            self.field_self.set_default();
        }
        self.field_self.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_self(&mut self) -> UserPresence {
        self.field_self.take().unwrap_or_else(|| UserPresence::new())
    }

    pub fn get_field_self(&self) -> &UserPresence {
        self.field_self.as_ref().unwrap_or_else(|| UserPresence::default_instance())
    }
}

impl ::protobuf::Message for Match {
    fn is_initialized(&self) -> bool {
        for v in &self.label {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.presences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_self {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.presences)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_self)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        if self.authoritative != false {
            my_size += 2;
        }
        if let Some(ref v) = self.label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.presences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        if self.authoritative != false {
            os.write_bool(2, self.authoritative)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int32(4, self.size)?;
        }
        for v in &self.presences {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Match {
        Match::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &Match| { &m.match_id },
                    |m: &mut Match| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "authoritative",
                    |m: &Match| { &m.authoritative },
                    |m: &mut Match| { &mut m.authoritative },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "label",
                    |m: &Match| { &m.label },
                    |m: &mut Match| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size",
                    |m: &Match| { &m.size },
                    |m: &mut Match| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presences",
                    |m: &Match| { &m.presences },
                    |m: &mut Match| { &mut m.presences },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "self",
                    |m: &Match| { &m.field_self },
                    |m: &mut Match| { &mut m.field_self },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Match>(
                    "Match",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Match {
        static mut instance: ::protobuf::lazy::Lazy<Match> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Match,
        };
        unsafe {
            instance.get(Match::new)
        }
    }
}

impl ::protobuf::Clear for Match {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_authoritative();
        self.clear_label();
        self.clear_size();
        self.clear_presences();
        self.clear_field_self();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Match {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchCreate {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchCreate {
    pub fn new() -> MatchCreate {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MatchCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchCreate {
        MatchCreate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MatchCreate>(
                    "MatchCreate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchCreate {
        static mut instance: ::protobuf::lazy::Lazy<MatchCreate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchCreate,
        };
        unsafe {
            instance.get(MatchCreate::new)
        }
    }
}

impl ::protobuf::Clear for MatchCreate {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchCreate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchData {
    // message fields
    pub match_id: ::std::string::String,
    pub presence: ::protobuf::SingularPtrField<UserPresence>,
    pub op_code: i64,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchData {
    pub fn new() -> MatchData {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }

    // .nakama.realtime.UserPresence presence = 2;

    pub fn clear_presence(&mut self) {
        self.presence.clear();
    }

    pub fn has_presence(&self) -> bool {
        self.presence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_presence(&mut self, v: UserPresence) {
        self.presence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presence(&mut self) -> &mut UserPresence {
        if self.presence.is_none() {
            self.presence.set_default();
        }
        self.presence.as_mut().unwrap()
    }

    // Take field
    pub fn take_presence(&mut self) -> UserPresence {
        self.presence.take().unwrap_or_else(|| UserPresence::new())
    }

    pub fn get_presence(&self) -> &UserPresence {
        self.presence.as_ref().unwrap_or_else(|| UserPresence::default_instance())
    }

    // int64 op_code = 3;

    pub fn clear_op_code(&mut self) {
        self.op_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_op_code(&mut self, v: i64) {
        self.op_code = v;
    }

    pub fn get_op_code(&self) -> i64 {
        self.op_code
    }

    // bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for MatchData {
    fn is_initialized(&self) -> bool {
        for v in &self.presence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.presence)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_code = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        if let Some(ref v) = self.presence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.op_code != 0 {
            my_size += ::protobuf::rt::value_size(3, self.op_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        if let Some(ref v) = self.presence.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.op_code != 0 {
            os.write_int64(3, self.op_code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchData {
        MatchData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &MatchData| { &m.match_id },
                    |m: &mut MatchData| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presence",
                    |m: &MatchData| { &m.presence },
                    |m: &mut MatchData| { &mut m.presence },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "op_code",
                    |m: &MatchData| { &m.op_code },
                    |m: &mut MatchData| { &mut m.op_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &MatchData| { &m.data },
                    |m: &mut MatchData| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchData>(
                    "MatchData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchData {
        static mut instance: ::protobuf::lazy::Lazy<MatchData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchData,
        };
        unsafe {
            instance.get(MatchData::new)
        }
    }
}

impl ::protobuf::Clear for MatchData {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_presence();
        self.clear_op_code();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchDataSend {
    // message fields
    pub match_id: ::std::string::String,
    pub op_code: i64,
    pub data: ::std::vec::Vec<u8>,
    pub presences: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchDataSend {
    pub fn new() -> MatchDataSend {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }

    // int64 op_code = 2;

    pub fn clear_op_code(&mut self) {
        self.op_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_op_code(&mut self, v: i64) {
        self.op_code = v;
    }

    pub fn get_op_code(&self) -> i64 {
        self.op_code
    }

    // bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // repeated .nakama.realtime.UserPresence presences = 4;

    pub fn clear_presences(&mut self) {
        self.presences.clear();
    }

    // Param is passed by value, moved
    pub fn set_presences(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.presences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_presences(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.presences
    }

    // Take field
    pub fn take_presences(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.presences, ::protobuf::RepeatedField::new())
    }

    pub fn get_presences(&self) -> &[UserPresence] {
        &self.presences
    }
}

impl ::protobuf::Message for MatchDataSend {
    fn is_initialized(&self) -> bool {
        for v in &self.presences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_code = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.presences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        if self.op_code != 0 {
            my_size += ::protobuf::rt::value_size(2, self.op_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        for value in &self.presences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        if self.op_code != 0 {
            os.write_int64(2, self.op_code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        for v in &self.presences {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchDataSend {
        MatchDataSend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &MatchDataSend| { &m.match_id },
                    |m: &mut MatchDataSend| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "op_code",
                    |m: &MatchDataSend| { &m.op_code },
                    |m: &mut MatchDataSend| { &mut m.op_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &MatchDataSend| { &m.data },
                    |m: &mut MatchDataSend| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presences",
                    |m: &MatchDataSend| { &m.presences },
                    |m: &mut MatchDataSend| { &mut m.presences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchDataSend>(
                    "MatchDataSend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchDataSend {
        static mut instance: ::protobuf::lazy::Lazy<MatchDataSend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchDataSend,
        };
        unsafe {
            instance.get(MatchDataSend::new)
        }
    }
}

impl ::protobuf::Clear for MatchDataSend {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_op_code();
        self.clear_data();
        self.clear_presences();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchDataSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchDataSend {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchJoin {
    // message fields
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub id: ::std::option::Option<MatchJoin_oneof_id>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum MatchJoin_oneof_id {
    match_id(::std::string::String),
    token(::std::string::String),
}

impl MatchJoin {
    pub fn new() -> MatchJoin {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::match_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(MatchJoin_oneof_id::match_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MatchJoin_oneof_id::match_id(_)) = self.id {
        } else {
            self.id = ::std::option::Option::Some(MatchJoin_oneof_id::match_id(::std::string::String::new()));
        }
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::match_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        if self.has_match_id() {
            match self.id.take() {
                ::std::option::Option::Some(MatchJoin_oneof_id::match_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_match_id(&self) -> &str {
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::match_id(ref v)) => v,
            _ => "",
        }
    }

    // string token = 2;

    pub fn clear_token(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::token(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(MatchJoin_oneof_id::token(v))
    }

    // Mutable pointer to the field.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MatchJoin_oneof_id::token(_)) = self.id {
        } else {
            self.id = ::std::option::Option::Some(MatchJoin_oneof_id::token(::std::string::String::new()));
        }
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::token(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        if self.has_token() {
            match self.id.take() {
                ::std::option::Option::Some(MatchJoin_oneof_id::token(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_token(&self) -> &str {
        match self.id {
            ::std::option::Option::Some(MatchJoin_oneof_id::token(ref v)) => v,
            _ => "",
        }
    }

    // repeated .nakama.realtime.MatchJoin.MetadataEntry metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
}

impl ::protobuf::Message for MatchJoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(MatchJoin_oneof_id::match_id(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(MatchJoin_oneof_id::token(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata);
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &MatchJoin_oneof_id::match_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &MatchJoin_oneof_id::token(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata, os)?;
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &MatchJoin_oneof_id::match_id(ref v) => {
                    os.write_string(1, v)?;
                },
                &MatchJoin_oneof_id::token(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchJoin {
        MatchJoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "match_id",
                    MatchJoin::has_match_id,
                    MatchJoin::get_match_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "token",
                    MatchJoin::has_token,
                    MatchJoin::get_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &MatchJoin| { &m.metadata },
                    |m: &mut MatchJoin| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchJoin>(
                    "MatchJoin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchJoin {
        static mut instance: ::protobuf::lazy::Lazy<MatchJoin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchJoin,
        };
        unsafe {
            instance.get(MatchJoin::new)
        }
    }
}

impl ::protobuf::Clear for MatchJoin {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_token();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchJoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchJoin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchLeave {
    // message fields
    pub match_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchLeave {
    pub fn new() -> MatchLeave {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }
}

impl ::protobuf::Message for MatchLeave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchLeave {
        MatchLeave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &MatchLeave| { &m.match_id },
                    |m: &mut MatchLeave| { &mut m.match_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchLeave>(
                    "MatchLeave",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchLeave {
        static mut instance: ::protobuf::lazy::Lazy<MatchLeave> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchLeave,
        };
        unsafe {
            instance.get(MatchLeave::new)
        }
    }
}

impl ::protobuf::Clear for MatchLeave {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchLeave {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchPresenceEvent {
    // message fields
    pub match_id: ::std::string::String,
    pub joins: ::protobuf::RepeatedField<UserPresence>,
    pub leaves: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchPresenceEvent {
    pub fn new() -> MatchPresenceEvent {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }

    // repeated .nakama.realtime.UserPresence joins = 2;

    pub fn clear_joins(&mut self) {
        self.joins.clear();
    }

    // Param is passed by value, moved
    pub fn set_joins(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.joins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_joins(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.joins
    }

    // Take field
    pub fn take_joins(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.joins, ::protobuf::RepeatedField::new())
    }

    pub fn get_joins(&self) -> &[UserPresence] {
        &self.joins
    }

    // repeated .nakama.realtime.UserPresence leaves = 3;

    pub fn clear_leaves(&mut self) {
        self.leaves.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaves(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.leaves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaves(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.leaves
    }

    // Take field
    pub fn take_leaves(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.leaves, ::protobuf::RepeatedField::new())
    }

    pub fn get_leaves(&self) -> &[UserPresence] {
        &self.leaves
    }
}

impl ::protobuf::Message for MatchPresenceEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.joins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leaves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.joins)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leaves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        for value in &self.joins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.leaves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        for v in &self.joins {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.leaves {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchPresenceEvent {
        MatchPresenceEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &MatchPresenceEvent| { &m.match_id },
                    |m: &mut MatchPresenceEvent| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "joins",
                    |m: &MatchPresenceEvent| { &m.joins },
                    |m: &mut MatchPresenceEvent| { &mut m.joins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "leaves",
                    |m: &MatchPresenceEvent| { &m.leaves },
                    |m: &mut MatchPresenceEvent| { &mut m.leaves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchPresenceEvent>(
                    "MatchPresenceEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchPresenceEvent {
        static mut instance: ::protobuf::lazy::Lazy<MatchPresenceEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchPresenceEvent,
        };
        unsafe {
            instance.get(MatchPresenceEvent::new)
        }
    }
}

impl ::protobuf::Clear for MatchPresenceEvent {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_joins();
        self.clear_leaves();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchPresenceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchPresenceEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchmakerAdd {
    // message fields
    pub min_count: i32,
    pub max_count: i32,
    pub query: ::std::string::String,
    pub string_properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub numeric_properties: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchmakerAdd {
    pub fn new() -> MatchmakerAdd {
        ::std::default::Default::default()
    }

    // int32 min_count = 1;

    pub fn clear_min_count(&mut self) {
        self.min_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_count(&mut self, v: i32) {
        self.min_count = v;
    }

    pub fn get_min_count(&self) -> i32 {
        self.min_count
    }

    // int32 max_count = 2;

    pub fn clear_max_count(&mut self) {
        self.max_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: i32) {
        self.max_count = v;
    }

    pub fn get_max_count(&self) -> i32 {
        self.max_count
    }

    // string query = 3;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    pub fn get_query(&self) -> &str {
        &self.query
    }

    // repeated .nakama.realtime.MatchmakerAdd.StringPropertiesEntry string_properties = 4;

    pub fn clear_string_properties(&mut self) {
        self.string_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.string_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.string_properties
    }

    // Take field
    pub fn take_string_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.string_properties, ::std::collections::HashMap::new())
    }

    pub fn get_string_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.string_properties
    }

    // repeated .nakama.realtime.MatchmakerAdd.NumericPropertiesEntry numeric_properties = 5;

    pub fn clear_numeric_properties(&mut self) {
        self.numeric_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_numeric_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.numeric_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numeric_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.numeric_properties
    }

    // Take field
    pub fn take_numeric_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.numeric_properties, ::std::collections::HashMap::new())
    }

    pub fn get_numeric_properties(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.numeric_properties
    }
}

impl ::protobuf::Message for MatchmakerAdd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_count = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.string_properties)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.numeric_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.min_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.query);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.string_properties);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(5, &self.numeric_properties);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.min_count != 0 {
            os.write_int32(1, self.min_count)?;
        }
        if self.max_count != 0 {
            os.write_int32(2, self.max_count)?;
        }
        if !self.query.is_empty() {
            os.write_string(3, &self.query)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.string_properties, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(5, &self.numeric_properties, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchmakerAdd {
        MatchmakerAdd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "min_count",
                    |m: &MatchmakerAdd| { &m.min_count },
                    |m: &mut MatchmakerAdd| { &mut m.min_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_count",
                    |m: &MatchmakerAdd| { &m.max_count },
                    |m: &mut MatchmakerAdd| { &mut m.max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &MatchmakerAdd| { &m.query },
                    |m: &mut MatchmakerAdd| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "string_properties",
                    |m: &MatchmakerAdd| { &m.string_properties },
                    |m: &mut MatchmakerAdd| { &mut m.string_properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "numeric_properties",
                    |m: &MatchmakerAdd| { &m.numeric_properties },
                    |m: &mut MatchmakerAdd| { &mut m.numeric_properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchmakerAdd>(
                    "MatchmakerAdd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchmakerAdd {
        static mut instance: ::protobuf::lazy::Lazy<MatchmakerAdd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchmakerAdd,
        };
        unsafe {
            instance.get(MatchmakerAdd::new)
        }
    }
}

impl ::protobuf::Clear for MatchmakerAdd {
    fn clear(&mut self) {
        self.clear_min_count();
        self.clear_max_count();
        self.clear_query();
        self.clear_string_properties();
        self.clear_numeric_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchmakerAdd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchmakerAdd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchmakerMatched {
    // message fields
    pub ticket: ::std::string::String,
    pub users: ::protobuf::RepeatedField<MatchmakerMatched_MatchmakerUser>,
    pub field_self: ::protobuf::SingularPtrField<MatchmakerMatched_MatchmakerUser>,
    // message oneof groups
    pub id: ::std::option::Option<MatchmakerMatched_oneof_id>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum MatchmakerMatched_oneof_id {
    match_id(::std::string::String),
    token(::std::string::String),
}

impl MatchmakerMatched {
    pub fn new() -> MatchmakerMatched {
        ::std::default::Default::default()
    }

    // string ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::string::String) {
        self.ticket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::string::String {
        &mut self.ticket
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticket, ::std::string::String::new())
    }

    pub fn get_ticket(&self) -> &str {
        &self.ticket
    }

    // string match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(_)) = self.id {
        } else {
            self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(::std::string::String::new()));
        }
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        if self.has_match_id() {
            match self.id.take() {
                ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_match_id(&self) -> &str {
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(ref v)) => v,
            _ => "",
        }
    }

    // string token = 3;

    pub fn clear_token(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(v))
    }

    // Mutable pointer to the field.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(_)) = self.id {
        } else {
            self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(::std::string::String::new()));
        }
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        if self.has_token() {
            match self.id.take() {
                ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_token(&self) -> &str {
        match self.id {
            ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(ref v)) => v,
            _ => "",
        }
    }

    // repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser users = 4;

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<MatchmakerMatched_MatchmakerUser>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<MatchmakerMatched_MatchmakerUser> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<MatchmakerMatched_MatchmakerUser> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    pub fn get_users(&self) -> &[MatchmakerMatched_MatchmakerUser] {
        &self.users
    }

    // .nakama.realtime.MatchmakerMatched.MatchmakerUser self = 5;

    pub fn clear_field_self(&mut self) {
        self.field_self.clear();
    }

    pub fn has_field_self(&self) -> bool {
        self.field_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: MatchmakerMatched_MatchmakerUser) {
        self.field_self = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_self(&mut self) -> &mut MatchmakerMatched_MatchmakerUser {
        if self.field_self.is_none() {
            self.field_self.set_default();
        }
        self.field_self.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_self(&mut self) -> MatchmakerMatched_MatchmakerUser {
        self.field_self.take().unwrap_or_else(|| MatchmakerMatched_MatchmakerUser::new())
    }

    pub fn get_field_self(&self) -> &MatchmakerMatched_MatchmakerUser {
        self.field_self.as_ref().unwrap_or_else(|| MatchmakerMatched_MatchmakerUser::default_instance())
    }
}

impl ::protobuf::Message for MatchmakerMatched {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_self {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::match_id(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id = ::std::option::Option::Some(MatchmakerMatched_oneof_id::token(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_self)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticket);
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &MatchmakerMatched_oneof_id::match_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &MatchmakerMatched_oneof_id::token(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ticket.is_empty() {
            os.write_string(1, &self.ticket)?;
        }
        for v in &self.users {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_self.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &MatchmakerMatched_oneof_id::match_id(ref v) => {
                    os.write_string(2, v)?;
                },
                &MatchmakerMatched_oneof_id::token(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchmakerMatched {
        MatchmakerMatched::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticket",
                    |m: &MatchmakerMatched| { &m.ticket },
                    |m: &mut MatchmakerMatched| { &mut m.ticket },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "match_id",
                    MatchmakerMatched::has_match_id,
                    MatchmakerMatched::get_match_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "token",
                    MatchmakerMatched::has_token,
                    MatchmakerMatched::get_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchmakerMatched_MatchmakerUser>>(
                    "users",
                    |m: &MatchmakerMatched| { &m.users },
                    |m: &mut MatchmakerMatched| { &mut m.users },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchmakerMatched_MatchmakerUser>>(
                    "self",
                    |m: &MatchmakerMatched| { &m.field_self },
                    |m: &mut MatchmakerMatched| { &mut m.field_self },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchmakerMatched>(
                    "MatchmakerMatched",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchmakerMatched {
        static mut instance: ::protobuf::lazy::Lazy<MatchmakerMatched> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchmakerMatched,
        };
        unsafe {
            instance.get(MatchmakerMatched::new)
        }
    }
}

impl ::protobuf::Clear for MatchmakerMatched {
    fn clear(&mut self) {
        self.clear_ticket();
        self.clear_match_id();
        self.clear_token();
        self.clear_users();
        self.clear_field_self();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchmakerMatched {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchmakerMatched {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchmakerMatched_MatchmakerUser {
    // message fields
    pub presence: ::protobuf::SingularPtrField<UserPresence>,
    pub string_properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub numeric_properties: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchmakerMatched_MatchmakerUser {
    pub fn new() -> MatchmakerMatched_MatchmakerUser {
        ::std::default::Default::default()
    }

    // .nakama.realtime.UserPresence presence = 1;

    pub fn clear_presence(&mut self) {
        self.presence.clear();
    }

    pub fn has_presence(&self) -> bool {
        self.presence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_presence(&mut self, v: UserPresence) {
        self.presence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presence(&mut self) -> &mut UserPresence {
        if self.presence.is_none() {
            self.presence.set_default();
        }
        self.presence.as_mut().unwrap()
    }

    // Take field
    pub fn take_presence(&mut self) -> UserPresence {
        self.presence.take().unwrap_or_else(|| UserPresence::new())
    }

    pub fn get_presence(&self) -> &UserPresence {
        self.presence.as_ref().unwrap_or_else(|| UserPresence::default_instance())
    }

    // repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser.StringPropertiesEntry string_properties = 5;

    pub fn clear_string_properties(&mut self) {
        self.string_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.string_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.string_properties
    }

    // Take field
    pub fn take_string_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.string_properties, ::std::collections::HashMap::new())
    }

    pub fn get_string_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.string_properties
    }

    // repeated .nakama.realtime.MatchmakerMatched.MatchmakerUser.NumericPropertiesEntry numeric_properties = 6;

    pub fn clear_numeric_properties(&mut self) {
        self.numeric_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_numeric_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.numeric_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numeric_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.numeric_properties
    }

    // Take field
    pub fn take_numeric_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.numeric_properties, ::std::collections::HashMap::new())
    }

    pub fn get_numeric_properties(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.numeric_properties
    }
}

impl ::protobuf::Message for MatchmakerMatched_MatchmakerUser {
    fn is_initialized(&self) -> bool {
        for v in &self.presence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.presence)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.string_properties)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.numeric_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.presence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.string_properties);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(6, &self.numeric_properties);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.presence.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.string_properties, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(6, &self.numeric_properties, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchmakerMatched_MatchmakerUser {
        MatchmakerMatched_MatchmakerUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presence",
                    |m: &MatchmakerMatched_MatchmakerUser| { &m.presence },
                    |m: &mut MatchmakerMatched_MatchmakerUser| { &mut m.presence },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "string_properties",
                    |m: &MatchmakerMatched_MatchmakerUser| { &m.string_properties },
                    |m: &mut MatchmakerMatched_MatchmakerUser| { &mut m.string_properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "numeric_properties",
                    |m: &MatchmakerMatched_MatchmakerUser| { &m.numeric_properties },
                    |m: &mut MatchmakerMatched_MatchmakerUser| { &mut m.numeric_properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchmakerMatched_MatchmakerUser>(
                    "MatchmakerMatched_MatchmakerUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchmakerMatched_MatchmakerUser {
        static mut instance: ::protobuf::lazy::Lazy<MatchmakerMatched_MatchmakerUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchmakerMatched_MatchmakerUser,
        };
        unsafe {
            instance.get(MatchmakerMatched_MatchmakerUser::new)
        }
    }
}

impl ::protobuf::Clear for MatchmakerMatched_MatchmakerUser {
    fn clear(&mut self) {
        self.clear_presence();
        self.clear_string_properties();
        self.clear_numeric_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchmakerMatched_MatchmakerUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchmakerMatched_MatchmakerUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchmakerRemove {
    // message fields
    pub ticket: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchmakerRemove {
    pub fn new() -> MatchmakerRemove {
        ::std::default::Default::default()
    }

    // string ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::string::String) {
        self.ticket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::string::String {
        &mut self.ticket
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticket, ::std::string::String::new())
    }

    pub fn get_ticket(&self) -> &str {
        &self.ticket
    }
}

impl ::protobuf::Message for MatchmakerRemove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticket);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ticket.is_empty() {
            os.write_string(1, &self.ticket)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchmakerRemove {
        MatchmakerRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticket",
                    |m: &MatchmakerRemove| { &m.ticket },
                    |m: &mut MatchmakerRemove| { &mut m.ticket },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchmakerRemove>(
                    "MatchmakerRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchmakerRemove {
        static mut instance: ::protobuf::lazy::Lazy<MatchmakerRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchmakerRemove,
        };
        unsafe {
            instance.get(MatchmakerRemove::new)
        }
    }
}

impl ::protobuf::Clear for MatchmakerRemove {
    fn clear(&mut self) {
        self.clear_ticket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchmakerRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchmakerRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchmakerTicket {
    // message fields
    pub ticket: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchmakerTicket {
    pub fn new() -> MatchmakerTicket {
        ::std::default::Default::default()
    }

    // string ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::string::String) {
        self.ticket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::string::String {
        &mut self.ticket
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticket, ::std::string::String::new())
    }

    pub fn get_ticket(&self) -> &str {
        &self.ticket
    }
}

impl ::protobuf::Message for MatchmakerTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticket);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ticket.is_empty() {
            os.write_string(1, &self.ticket)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchmakerTicket {
        MatchmakerTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticket",
                    |m: &MatchmakerTicket| { &m.ticket },
                    |m: &mut MatchmakerTicket| { &mut m.ticket },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchmakerTicket>(
                    "MatchmakerTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchmakerTicket {
        static mut instance: ::protobuf::lazy::Lazy<MatchmakerTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchmakerTicket,
        };
        unsafe {
            instance.get(MatchmakerTicket::new)
        }
    }
}

impl ::protobuf::Clear for MatchmakerTicket {
    fn clear(&mut self) {
        self.clear_ticket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchmakerTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchmakerTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Notifications {
    // message fields
    pub notifications: ::protobuf::RepeatedField<super::api::Notification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Notifications {
    pub fn new() -> Notifications {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Notification notifications = 1;

    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<super::api::Notification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<super::api::Notification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<super::api::Notification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }

    pub fn get_notifications(&self) -> &[super::api::Notification] {
        &self.notifications
    }
}

impl ::protobuf::Message for Notifications {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notifications {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notifications {
        Notifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Notification>>(
                    "notifications",
                    |m: &Notifications| { &m.notifications },
                    |m: &mut Notifications| { &mut m.notifications },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Notifications>(
                    "Notifications",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Notifications {
        static mut instance: ::protobuf::lazy::Lazy<Notifications> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Notifications,
        };
        unsafe {
            instance.get(Notifications::new)
        }
    }
}

impl ::protobuf::Clear for Notifications {
    fn clear(&mut self) {
        self.clear_notifications();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notifications {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub presences: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // repeated .nakama.realtime.UserPresence presences = 1;

    pub fn clear_presences(&mut self) {
        self.presences.clear();
    }

    // Param is passed by value, moved
    pub fn set_presences(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.presences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_presences(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.presences
    }

    // Take field
    pub fn take_presences(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.presences, ::protobuf::RepeatedField::new())
    }

    pub fn get_presences(&self) -> &[UserPresence] {
        &self.presences
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.presences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.presences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.presences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.presences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "presences",
                    |m: &Status| { &m.presences },
                    |m: &mut Status| { &mut m.presences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.clear_presences();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusFollow {
    // message fields
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusFollow {
    pub fn new() -> StatusFollow {
        ::std::default::Default::default()
    }

    // repeated string user_ids = 1;

    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
}

impl ::protobuf::Message for StatusFollow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.user_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusFollow {
        StatusFollow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_ids",
                    |m: &StatusFollow| { &m.user_ids },
                    |m: &mut StatusFollow| { &mut m.user_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusFollow>(
                    "StatusFollow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusFollow {
        static mut instance: ::protobuf::lazy::Lazy<StatusFollow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusFollow,
        };
        unsafe {
            instance.get(StatusFollow::new)
        }
    }
}

impl ::protobuf::Clear for StatusFollow {
    fn clear(&mut self) {
        self.clear_user_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusFollow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusFollow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusPresenceEvent {
    // message fields
    pub joins: ::protobuf::RepeatedField<UserPresence>,
    pub leaves: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusPresenceEvent {
    pub fn new() -> StatusPresenceEvent {
        ::std::default::Default::default()
    }

    // repeated .nakama.realtime.UserPresence joins = 2;

    pub fn clear_joins(&mut self) {
        self.joins.clear();
    }

    // Param is passed by value, moved
    pub fn set_joins(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.joins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_joins(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.joins
    }

    // Take field
    pub fn take_joins(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.joins, ::protobuf::RepeatedField::new())
    }

    pub fn get_joins(&self) -> &[UserPresence] {
        &self.joins
    }

    // repeated .nakama.realtime.UserPresence leaves = 3;

    pub fn clear_leaves(&mut self) {
        self.leaves.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaves(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.leaves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaves(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.leaves
    }

    // Take field
    pub fn take_leaves(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.leaves, ::protobuf::RepeatedField::new())
    }

    pub fn get_leaves(&self) -> &[UserPresence] {
        &self.leaves
    }
}

impl ::protobuf::Message for StatusPresenceEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.joins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leaves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.joins)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leaves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.joins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.leaves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.joins {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.leaves {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusPresenceEvent {
        StatusPresenceEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "joins",
                    |m: &StatusPresenceEvent| { &m.joins },
                    |m: &mut StatusPresenceEvent| { &mut m.joins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "leaves",
                    |m: &StatusPresenceEvent| { &m.leaves },
                    |m: &mut StatusPresenceEvent| { &mut m.leaves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusPresenceEvent>(
                    "StatusPresenceEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusPresenceEvent {
        static mut instance: ::protobuf::lazy::Lazy<StatusPresenceEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusPresenceEvent,
        };
        unsafe {
            instance.get(StatusPresenceEvent::new)
        }
    }
}

impl ::protobuf::Clear for StatusPresenceEvent {
    fn clear(&mut self) {
        self.clear_joins();
        self.clear_leaves();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusPresenceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusPresenceEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusUnfollow {
    // message fields
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusUnfollow {
    pub fn new() -> StatusUnfollow {
        ::std::default::Default::default()
    }

    // repeated string user_ids = 1;

    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
}

impl ::protobuf::Message for StatusUnfollow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.user_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusUnfollow {
        StatusUnfollow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_ids",
                    |m: &StatusUnfollow| { &m.user_ids },
                    |m: &mut StatusUnfollow| { &mut m.user_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusUnfollow>(
                    "StatusUnfollow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusUnfollow {
        static mut instance: ::protobuf::lazy::Lazy<StatusUnfollow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusUnfollow,
        };
        unsafe {
            instance.get(StatusUnfollow::new)
        }
    }
}

impl ::protobuf::Clear for StatusUnfollow {
    fn clear(&mut self) {
        self.clear_user_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusUnfollow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusUnfollow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusUpdate {
    // message fields
    pub status: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusUpdate {
    pub fn new() -> StatusUpdate {
        ::std::default::Default::default()
    }

    // .google.protobuf.StringValue status = 1;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.status.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_status(&self) -> &::protobuf::well_known_types::StringValue {
        self.status.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }
}

impl ::protobuf::Message for StatusUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusUpdate {
        StatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "status",
                    |m: &StatusUpdate| { &m.status },
                    |m: &mut StatusUpdate| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusUpdate>(
                    "StatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<StatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusUpdate,
        };
        unsafe {
            instance.get(StatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for StatusUpdate {
    fn clear(&mut self) {
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stream {
    // message fields
    pub mode: i32,
    pub subject: ::std::string::String,
    pub subcontext: ::std::string::String,
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // int32 mode = 1;

    pub fn clear_mode(&mut self) {
        self.mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = v;
    }

    pub fn get_mode(&self) -> i32 {
        self.mode
    }

    // string subject = 2;

    pub fn clear_subject(&mut self) {
        self.subject.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        &mut self.subject
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subject, ::std::string::String::new())
    }

    pub fn get_subject(&self) -> &str {
        &self.subject
    }

    // string subcontext = 3;

    pub fn clear_subcontext(&mut self) {
        self.subcontext.clear();
    }

    // Param is passed by value, moved
    pub fn set_subcontext(&mut self, v: ::std::string::String) {
        self.subcontext = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subcontext(&mut self) -> &mut ::std::string::String {
        &mut self.subcontext
    }

    // Take field
    pub fn take_subcontext(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subcontext, ::std::string::String::new())
    }

    pub fn get_subcontext(&self) -> &str {
        &self.subcontext
    }

    // string label = 4;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    pub fn get_label(&self) -> &str {
        &self.label
    }
}

impl ::protobuf::Message for Stream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subject)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subcontext)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subject);
        }
        if !self.subcontext.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subcontext);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mode != 0 {
            os.write_int32(1, self.mode)?;
        }
        if !self.subject.is_empty() {
            os.write_string(2, &self.subject)?;
        }
        if !self.subcontext.is_empty() {
            os.write_string(3, &self.subcontext)?;
        }
        if !self.label.is_empty() {
            os.write_string(4, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    |m: &Stream| { &m.mode },
                    |m: &mut Stream| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subject",
                    |m: &Stream| { &m.subject },
                    |m: &mut Stream| { &mut m.subject },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subcontext",
                    |m: &Stream| { &m.subcontext },
                    |m: &mut Stream| { &mut m.subcontext },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Stream| { &m.label },
                    |m: &mut Stream| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stream>(
                    "Stream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stream {
        static mut instance: ::protobuf::lazy::Lazy<Stream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stream,
        };
        unsafe {
            instance.get(Stream::new)
        }
    }
}

impl ::protobuf::Clear for Stream {
    fn clear(&mut self) {
        self.clear_mode();
        self.clear_subject();
        self.clear_subcontext();
        self.clear_label();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamData {
    // message fields
    pub stream: ::protobuf::SingularPtrField<Stream>,
    pub sender: ::protobuf::SingularPtrField<UserPresence>,
    pub data: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StreamData {
    pub fn new() -> StreamData {
        ::std::default::Default::default()
    }

    // .nakama.realtime.Stream stream = 1;

    pub fn clear_stream(&mut self) {
        self.stream.clear();
    }

    pub fn has_stream(&self) -> bool {
        self.stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: Stream) {
        self.stream = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream(&mut self) -> &mut Stream {
        if self.stream.is_none() {
            self.stream.set_default();
        }
        self.stream.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream(&mut self) -> Stream {
        self.stream.take().unwrap_or_else(|| Stream::new())
    }

    pub fn get_stream(&self) -> &Stream {
        self.stream.as_ref().unwrap_or_else(|| Stream::default_instance())
    }

    // .nakama.realtime.UserPresence sender = 2;

    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: UserPresence) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut UserPresence {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> UserPresence {
        self.sender.take().unwrap_or_else(|| UserPresence::new())
    }

    pub fn get_sender(&self) -> &UserPresence {
        self.sender.as_ref().unwrap_or_else(|| UserPresence::default_instance())
    }

    // string data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }

    pub fn get_data(&self) -> &str {
        &self.data
    }
}

impl ::protobuf::Message for StreamData {
    fn is_initialized(&self) -> bool {
        for v in &self.stream {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data.is_empty() {
            os.write_string(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamData {
        StreamData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                    "stream",
                    |m: &StreamData| { &m.stream },
                    |m: &mut StreamData| { &mut m.stream },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "sender",
                    |m: &StreamData| { &m.sender },
                    |m: &mut StreamData| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    |m: &StreamData| { &m.data },
                    |m: &mut StreamData| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamData>(
                    "StreamData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamData {
        static mut instance: ::protobuf::lazy::Lazy<StreamData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamData,
        };
        unsafe {
            instance.get(StreamData::new)
        }
    }
}

impl ::protobuf::Clear for StreamData {
    fn clear(&mut self) {
        self.clear_stream();
        self.clear_sender();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamPresenceEvent {
    // message fields
    pub stream: ::protobuf::SingularPtrField<Stream>,
    pub joins: ::protobuf::RepeatedField<UserPresence>,
    pub leaves: ::protobuf::RepeatedField<UserPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StreamPresenceEvent {
    pub fn new() -> StreamPresenceEvent {
        ::std::default::Default::default()
    }

    // .nakama.realtime.Stream stream = 1;

    pub fn clear_stream(&mut self) {
        self.stream.clear();
    }

    pub fn has_stream(&self) -> bool {
        self.stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: Stream) {
        self.stream = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream(&mut self) -> &mut Stream {
        if self.stream.is_none() {
            self.stream.set_default();
        }
        self.stream.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream(&mut self) -> Stream {
        self.stream.take().unwrap_or_else(|| Stream::new())
    }

    pub fn get_stream(&self) -> &Stream {
        self.stream.as_ref().unwrap_or_else(|| Stream::default_instance())
    }

    // repeated .nakama.realtime.UserPresence joins = 2;

    pub fn clear_joins(&mut self) {
        self.joins.clear();
    }

    // Param is passed by value, moved
    pub fn set_joins(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.joins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_joins(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.joins
    }

    // Take field
    pub fn take_joins(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.joins, ::protobuf::RepeatedField::new())
    }

    pub fn get_joins(&self) -> &[UserPresence] {
        &self.joins
    }

    // repeated .nakama.realtime.UserPresence leaves = 3;

    pub fn clear_leaves(&mut self) {
        self.leaves.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaves(&mut self, v: ::protobuf::RepeatedField<UserPresence>) {
        self.leaves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaves(&mut self) -> &mut ::protobuf::RepeatedField<UserPresence> {
        &mut self.leaves
    }

    // Take field
    pub fn take_leaves(&mut self) -> ::protobuf::RepeatedField<UserPresence> {
        ::std::mem::replace(&mut self.leaves, ::protobuf::RepeatedField::new())
    }

    pub fn get_leaves(&self) -> &[UserPresence] {
        &self.leaves
    }
}

impl ::protobuf::Message for StreamPresenceEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.stream {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.joins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leaves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.joins)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leaves)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.joins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.leaves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.joins {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.leaves {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamPresenceEvent {
        StreamPresenceEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                    "stream",
                    |m: &StreamPresenceEvent| { &m.stream },
                    |m: &mut StreamPresenceEvent| { &mut m.stream },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "joins",
                    |m: &StreamPresenceEvent| { &m.joins },
                    |m: &mut StreamPresenceEvent| { &mut m.joins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserPresence>>(
                    "leaves",
                    |m: &StreamPresenceEvent| { &m.leaves },
                    |m: &mut StreamPresenceEvent| { &mut m.leaves },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamPresenceEvent>(
                    "StreamPresenceEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamPresenceEvent {
        static mut instance: ::protobuf::lazy::Lazy<StreamPresenceEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamPresenceEvent,
        };
        unsafe {
            instance.get(StreamPresenceEvent::new)
        }
    }
}

impl ::protobuf::Clear for StreamPresenceEvent {
    fn clear(&mut self) {
        self.clear_stream();
        self.clear_joins();
        self.clear_leaves();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamPresenceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamPresenceEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserPresence {
    // message fields
    pub user_id: ::std::string::String,
    pub session_id: ::std::string::String,
    pub username: ::std::string::String,
    pub persistence: bool,
    pub status: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UserPresence {
    pub fn new() -> UserPresence {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // string session_id = 2;

    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::string::String) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::string::String {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_id, ::std::string::String::new())
    }

    pub fn get_session_id(&self) -> &str {
        &self.session_id
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // bool persistence = 4;

    pub fn clear_persistence(&mut self) {
        self.persistence = false;
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: bool) {
        self.persistence = v;
    }

    pub fn get_persistence(&self) -> bool {
        self.persistence
    }

    // .google.protobuf.StringValue status = 5;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.status.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_status(&self) -> &::protobuf::well_known_types::StringValue {
        self.status.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }
}

impl ::protobuf::Message for UserPresence {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persistence = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.session_id);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        if self.persistence != false {
            my_size += 2;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.session_id.is_empty() {
            os.write_string(2, &self.session_id)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        if self.persistence != false {
            os.write_bool(4, self.persistence)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserPresence {
        UserPresence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &UserPresence| { &m.user_id },
                    |m: &mut UserPresence| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "session_id",
                    |m: &UserPresence| { &m.session_id },
                    |m: &mut UserPresence| { &mut m.session_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &UserPresence| { &m.username },
                    |m: &mut UserPresence| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "persistence",
                    |m: &UserPresence| { &m.persistence },
                    |m: &mut UserPresence| { &mut m.persistence },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "status",
                    |m: &UserPresence| { &m.status },
                    |m: &mut UserPresence| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserPresence>(
                    "UserPresence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserPresence {
        static mut instance: ::protobuf::lazy::Lazy<UserPresence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserPresence,
        };
        unsafe {
            instance.get(UserPresence::new)
        }
    }
}

impl ::protobuf::Clear for UserPresence {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_session_id();
        self.clear_username();
        self.clear_persistence();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserPresence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserPresence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1github.com/heroiclabs/nakama/rtapi/realtime.proto\x12\x0fnakama.realt\
    ime\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappe\
    rs.proto\x1a*github.com/heroiclabs/nakama/api/api.proto\"\xab\x11\n\x08E\
    nvelope\x12\x10\n\x03cid\x18\x01\x20\x01(\tR\x03cid\x124\n\x07channel\
    \x18\x02\x20\x01(\x0b2\x18.nakama.realtime.ChannelH\0R\x07channel\x12A\n\
    \x0cchannel_join\x18\x03\x20\x01(\x0b2\x1c.nakama.realtime.ChannelJoinH\
    \0R\x0bchannelJoin\x12D\n\rchannel_leave\x18\x04\x20\x01(\x0b2\x1d.nakam\
    a.realtime.ChannelLeaveH\0R\x0cchannelLeave\x12E\n\x0fchannel_message\
    \x18\x05\x20\x01(\x0b2\x1a.nakama.api.ChannelMessageH\0R\x0echannelMessa\
    ge\x12T\n\x13channel_message_ack\x18\x06\x20\x01(\x0b2\".nakama.realtime\
    .ChannelMessageAckH\0R\x11channelMessageAck\x12W\n\x14channel_message_se\
    nd\x18\x07\x20\x01(\x0b2#.nakama.realtime.ChannelMessageSendH\0R\x12chan\
    nelMessageSend\x12]\n\x16channel_message_update\x18\x08\x20\x01(\x0b2%.n\
    akama.realtime.ChannelMessageUpdateH\0R\x14channelMessageUpdate\x12]\n\
    \x16channel_message_remove\x18\t\x20\x01(\x0b2%.nakama.realtime.ChannelM\
    essageRemoveH\0R\x14channelMessageRemove\x12]\n\x16channel_presence_even\
    t\x18\n\x20\x01(\x0b2%.nakama.realtime.ChannelPresenceEventH\0R\x14chann\
    elPresenceEvent\x12.\n\x05error\x18\x0b\x20\x01(\x0b2\x16.nakama.realtim\
    e.ErrorH\0R\x05error\x12.\n\x05match\x18\x0c\x20\x01(\x0b2\x16.nakama.re\
    altime.MatchH\0R\x05match\x12A\n\x0cmatch_create\x18\r\x20\x01(\x0b2\x1c\
    .nakama.realtime.MatchCreateH\0R\x0bmatchCreate\x12;\n\nmatch_data\x18\
    \x0e\x20\x01(\x0b2\x1a.nakama.realtime.MatchDataH\0R\tmatchData\x12H\n\
    \x0fmatch_data_send\x18\x0f\x20\x01(\x0b2\x1e.nakama.realtime.MatchDataS\
    endH\0R\rmatchDataSend\x12;\n\nmatch_join\x18\x10\x20\x01(\x0b2\x1a.naka\
    ma.realtime.MatchJoinH\0R\tmatchJoin\x12>\n\x0bmatch_leave\x18\x11\x20\
    \x01(\x0b2\x1b.nakama.realtime.MatchLeaveH\0R\nmatchLeave\x12W\n\x14matc\
    h_presence_event\x18\x12\x20\x01(\x0b2#.nakama.realtime.MatchPresenceEve\
    ntH\0R\x12matchPresenceEvent\x12G\n\x0ematchmaker_add\x18\x13\x20\x01(\
    \x0b2\x1e.nakama.realtime.MatchmakerAddH\0R\rmatchmakerAdd\x12S\n\x12mat\
    chmaker_matched\x18\x14\x20\x01(\x0b2\".nakama.realtime.MatchmakerMatche\
    dH\0R\x11matchmakerMatched\x12P\n\x11matchmaker_remove\x18\x15\x20\x01(\
    \x0b2!.nakama.realtime.MatchmakerRemoveH\0R\x10matchmakerRemove\x12P\n\
    \x11matchmaker_ticket\x18\x16\x20\x01(\x0b2!.nakama.realtime.MatchmakerT\
    icketH\0R\x10matchmakerTicket\x12F\n\rnotifications\x18\x17\x20\x01(\x0b\
    2\x1e.nakama.realtime.NotificationsH\0R\rnotifications\x12#\n\x03rpc\x18\
    \x18\x20\x01(\x0b2\x0f.nakama.api.RpcH\0R\x03rpc\x121\n\x06status\x18\
    \x19\x20\x01(\x0b2\x17.nakama.realtime.StatusH\0R\x06status\x12D\n\rstat\
    us_follow\x18\x1a\x20\x01(\x0b2\x1d.nakama.realtime.StatusFollowH\0R\x0c\
    statusFollow\x12Z\n\x15status_presence_event\x18\x1b\x20\x01(\x0b2$.naka\
    ma.realtime.StatusPresenceEventH\0R\x13statusPresenceEvent\x12J\n\x0fsta\
    tus_unfollow\x18\x1c\x20\x01(\x0b2\x1f.nakama.realtime.StatusUnfollowH\0\
    R\x0estatusUnfollow\x12D\n\rstatus_update\x18\x1d\x20\x01(\x0b2\x1d.naka\
    ma.realtime.StatusUpdateH\0R\x0cstatusUpdate\x12>\n\x0bstream_data\x18\
    \x1e\x20\x01(\x0b2\x1b.nakama.realtime.StreamDataH\0R\nstreamData\x12Z\n\
    \x15stream_presence_event\x18\x1f\x20\x01(\x0b2$.nakama.realtime.StreamP\
    resenceEventH\0R\x13streamPresenceEventB\t\n\x07message\"\x89\x01\n\x07C\
    hannel\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12;\n\tpresences\x18\
    \x02\x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\tpresences\x121\n\
    \x04self\x18\x03\x20\x01(\x0b2\x1d.nakama.realtime.UserPresenceR\x04self\
    \"\xf2\x01\n\x0bChannelJoin\x12\x16\n\x06target\x18\x01\x20\x01(\tR\x06t\
    arget\x12\x12\n\x04type\x18\x02\x20\x01(\x05R\x04type\x12<\n\x0bpersiste\
    nce\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x0bpersistence\
    \x122\n\x06hidden\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\
    \x06hidden\"E\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x08\n\
    \x04ROOM\x10\x01\x12\x12\n\x0eDIRECT_MESSAGE\x10\x02\x12\t\n\x05GROUP\
    \x10\x03\"-\n\x0cChannelLeave\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\tR\
    \tchannelId\"\xd4\x02\n\x11ChannelMessageAck\x12\x1d\n\nchannel_id\x18\
    \x01\x20\x01(\tR\tchannelId\x12\x1d\n\nmessage_id\x18\x02\x20\x01(\tR\tm\
    essageId\x12/\n\x04code\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int32V\
    alueR\x04code\x12\x1a\n\x08username\x18\x04\x20\x01(\tR\x08username\x12;\
    \n\x0bcreate_time\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\n\
    createTime\x12;\n\x0bupdate_time\x18\x06\x20\x01(\x0b2\x1a.google.protob\
    uf.TimestampR\nupdateTime\x12:\n\npersistent\x18\x07\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.BoolValueR\npersistent\"M\n\x12ChannelMessageSend\x12\x1d\
    \n\nchannel_id\x18\x01\x20\x01(\tR\tchannelId\x12\x18\n\x07content\x18\
    \x02\x20\x01(\tR\x07content\"n\n\x14ChannelMessageUpdate\x12\x1d\n\nchan\
    nel_id\x18\x01\x20\x01(\tR\tchannelId\x12\x1d\n\nmessage_id\x18\x02\x20\
    \x01(\tR\tmessageId\x12\x18\n\x07content\x18\x03\x20\x01(\tR\x07content\
    \"T\n\x14ChannelMessageRemove\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\tR\
    \tchannelId\x12\x1d\n\nmessage_id\x18\x02\x20\x01(\tR\tmessageId\"\xa1\
    \x01\n\x14ChannelPresenceEvent\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\tR\
    \tchannelId\x123\n\x05joins\x18\x02\x20\x03(\x0b2\x1d.nakama.realtime.Us\
    erPresenceR\x05joins\x125\n\x06leaves\x18\x03\x20\x03(\x0b2\x1d.nakama.r\
    ealtime.UserPresenceR\x06leaves\"\xfc\x02\n\x05Error\x12\x12\n\x04code\
    \x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\x12=\n\x07context\x18\x03\x20\x03(\x0b2#.nakama.realtime.Err\
    or.ContextEntryR\x07context\x1a:\n\x0cContextEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\"\xc9\x01\n\x04Code\x12\x15\n\x11RUNTIME_EXCEPTION\x10\0\x12\
    \x18\n\x14UNRECOGNIZED_PAYLOAD\x10\x01\x12\x13\n\x0fMISSING_PAYLOAD\x10\
    \x02\x12\r\n\tBAD_INPUT\x10\x03\x12\x13\n\x0fMATCH_NOT_FOUND\x10\x04\x12\
    \x17\n\x13MATCH_JOIN_REJECTED\x10\x05\x12\x1e\n\x1aRUNTIME_FUNCTION_NOT_\
    FOUND\x10\x06\x12\x1e\n\x1aRUNTIME_FUNCTION_EXCEPTION\x10\x07\"\x80\x02\
    \n\x05Match\x12\x19\n\x08match_id\x18\x01\x20\x01(\tR\x07matchId\x12$\n\
    \rauthoritative\x18\x02\x20\x01(\x08R\rauthoritative\x122\n\x05label\x18\
    \x03\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\x05label\x12\x12\n\
    \x04size\x18\x04\x20\x01(\x05R\x04size\x12;\n\tpresences\x18\x05\x20\x03\
    (\x0b2\x1d.nakama.realtime.UserPresenceR\tpresences\x121\n\x04self\x18\
    \x06\x20\x01(\x0b2\x1d.nakama.realtime.UserPresenceR\x04self\"\r\n\x0bMa\
    tchCreate\"\x8e\x01\n\tMatchData\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \tR\x07matchId\x129\n\x08presence\x18\x02\x20\x01(\x0b2\x1d.nakama.realt\
    ime.UserPresenceR\x08presence\x12\x17\n\x07op_code\x18\x03\x20\x01(\x03R\
    \x06opCode\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\"\x94\x01\n\r\
    MatchDataSend\x12\x19\n\x08match_id\x18\x01\x20\x01(\tR\x07matchId\x12\
    \x17\n\x07op_code\x18\x02\x20\x01(\x03R\x06opCode\x12\x12\n\x04data\x18\
    \x03\x20\x01(\x0cR\x04data\x12;\n\tpresences\x18\x04\x20\x03(\x0b2\x1d.n\
    akama.realtime.UserPresenceR\tpresences\"\xc9\x01\n\tMatchJoin\x12\x1b\n\
    \x08match_id\x18\x01\x20\x01(\tH\0R\x07matchId\x12\x16\n\x05token\x18\
    \x02\x20\x01(\tH\0R\x05token\x12D\n\x08metadata\x18\x03\x20\x03(\x0b2(.n\
    akama.realtime.MatchJoin.MetadataEntryR\x08metadata\x1a;\n\rMetadataEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01B\x04\n\x02id\"'\n\nMatchLeave\x12\x19\n\
    \x08match_id\x18\x01\x20\x01(\tR\x07matchId\"\x9b\x01\n\x12MatchPresence\
    Event\x12\x19\n\x08match_id\x18\x01\x20\x01(\tR\x07matchId\x123\n\x05joi\
    ns\x18\x02\x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\x05joins\x125\
    \n\x06leaves\x18\x03\x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\x06\
    leaves\"\xb3\x03\n\rMatchmakerAdd\x12\x1b\n\tmin_count\x18\x01\x20\x01(\
    \x05R\x08minCount\x12\x1b\n\tmax_count\x18\x02\x20\x01(\x05R\x08maxCount\
    \x12\x14\n\x05query\x18\x03\x20\x01(\tR\x05query\x12a\n\x11string_proper\
    ties\x18\x04\x20\x03(\x0b24.nakama.realtime.MatchmakerAdd.StringProperti\
    esEntryR\x10stringProperties\x12d\n\x12numeric_properties\x18\x05\x20\
    \x03(\x0b25.nakama.realtime.MatchmakerAdd.NumericPropertiesEntryR\x11num\
    ericProperties\x1aC\n\x15StringPropertiesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1aD\n\x16NumericPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01\"\
    \xbe\x05\n\x11MatchmakerMatched\x12\x16\n\x06ticket\x18\x01\x20\x01(\tR\
    \x06ticket\x12\x1b\n\x08match_id\x18\x02\x20\x01(\tH\0R\x07matchId\x12\
    \x16\n\x05token\x18\x03\x20\x01(\tH\0R\x05token\x12G\n\x05users\x18\x04\
    \x20\x03(\x0b21.nakama.realtime.MatchmakerMatched.MatchmakerUserR\x05use\
    rs\x12E\n\x04self\x18\x05\x20\x01(\x0b21.nakama.realtime.MatchmakerMatch\
    ed.MatchmakerUserR\x04self\x1a\xc5\x03\n\x0eMatchmakerUser\x129\n\x08pre\
    sence\x18\x01\x20\x01(\x0b2\x1d.nakama.realtime.UserPresenceR\x08presenc\
    e\x12t\n\x11string_properties\x18\x05\x20\x03(\x0b2G.nakama.realtime.Mat\
    chmakerMatched.MatchmakerUser.StringPropertiesEntryR\x10stringProperties\
    \x12w\n\x12numeric_properties\x18\x06\x20\x03(\x0b2H.nakama.realtime.Mat\
    chmakerMatched.MatchmakerUser.NumericPropertiesEntryR\x11numericProperti\
    es\x1aC\n\x15StringPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aD\n\
    \x16NumericPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01B\x04\n\x02i\
    d\"*\n\x10MatchmakerRemove\x12\x16\n\x06ticket\x18\x01\x20\x01(\tR\x06ti\
    cket\"*\n\x10MatchmakerTicket\x12\x16\n\x06ticket\x18\x01\x20\x01(\tR\
    \x06ticket\"O\n\rNotifications\x12>\n\rnotifications\x18\x01\x20\x03(\
    \x0b2\x18.nakama.api.NotificationR\rnotifications\"E\n\x06Status\x12;\n\
    \tpresences\x18\x01\x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\tpre\
    sences\")\n\x0cStatusFollow\x12\x19\n\x08user_ids\x18\x01\x20\x03(\tR\
    \x07userIds\"\x81\x01\n\x13StatusPresenceEvent\x123\n\x05joins\x18\x02\
    \x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\x05joins\x125\n\x06leav\
    es\x18\x03\x20\x03(\x0b2\x1d.nakama.realtime.UserPresenceR\x06leaves\"+\
    \n\x0eStatusUnfollow\x12\x19\n\x08user_ids\x18\x01\x20\x03(\tR\x07userId\
    s\"D\n\x0cStatusUpdate\x124\n\x06status\x18\x01\x20\x01(\x0b2\x1c.google\
    .protobuf.StringValueR\x06status\"l\n\x06Stream\x12\x12\n\x04mode\x18\
    \x01\x20\x01(\x05R\x04mode\x12\x18\n\x07subject\x18\x02\x20\x01(\tR\x07s\
    ubject\x12\x1e\n\nsubcontext\x18\x03\x20\x01(\tR\nsubcontext\x12\x14\n\
    \x05label\x18\x04\x20\x01(\tR\x05label\"\x88\x01\n\nStreamData\x12/\n\
    \x06stream\x18\x01\x20\x01(\x0b2\x17.nakama.realtime.StreamR\x06stream\
    \x125\n\x06sender\x18\x02\x20\x01(\x0b2\x1d.nakama.realtime.UserPresence\
    R\x06sender\x12\x12\n\x04data\x18\x03\x20\x01(\tR\x04data\"\xb2\x01\n\
    \x13StreamPresenceEvent\x12/\n\x06stream\x18\x01\x20\x01(\x0b2\x17.nakam\
    a.realtime.StreamR\x06stream\x123\n\x05joins\x18\x02\x20\x03(\x0b2\x1d.n\
    akama.realtime.UserPresenceR\x05joins\x125\n\x06leaves\x18\x03\x20\x03(\
    \x0b2\x1d.nakama.realtime.UserPresenceR\x06leaves\"\xba\x01\n\x0cUserPre\
    sence\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\x12\x1d\n\nsess\
    ion_id\x18\x02\x20\x01(\tR\tsessionId\x12\x1a\n\x08username\x18\x03\x20\
    \x01(\tR\x08username\x12\x20\n\x0bpersistence\x18\x04\x20\x01(\x08R\x0bp\
    ersistence\x124\n\x06status\x18\x05\x20\x01(\x0b2\x1c.google.protobuf.St\
    ringValueR\x06statusBF\n\x1bcom.heroiclabs.nakama.rtapiB\x0eNakamaRealti\
    meP\x01Z\x05rtapi\xa2\x02\x04NKPB\xaa\x02\x06Nakamab\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
