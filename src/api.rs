// This file is generated by rust-protobuf 2.4.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Account {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    pub wallet: ::std::string::String,
    pub email: ::std::string::String,
    pub devices: ::protobuf::RepeatedField<AccountDevice>,
    pub custom_id: ::std::string::String,
    pub verify_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    // .nakama.api.User user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }

    // string wallet = 2;

    pub fn clear_wallet(&mut self) {
        self.wallet.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet(&mut self, v: ::std::string::String) {
        self.wallet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet(&mut self) -> &mut ::std::string::String {
        &mut self.wallet
    }

    // Take field
    pub fn take_wallet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.wallet, ::std::string::String::new())
    }

    pub fn get_wallet(&self) -> &str {
        &self.wallet
    }

    // string email = 3;

    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    pub fn get_email(&self) -> &str {
        &self.email
    }

    // repeated .nakama.api.AccountDevice devices = 4;

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<AccountDevice>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<AccountDevice> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<AccountDevice> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }

    pub fn get_devices(&self) -> &[AccountDevice] {
        &self.devices
    }

    // string custom_id = 5;

    pub fn clear_custom_id(&mut self) {
        self.custom_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_id(&mut self, v: ::std::string::String) {
        self.custom_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_id(&mut self) -> &mut ::std::string::String {
        &mut self.custom_id
    }

    // Take field
    pub fn take_custom_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_id, ::std::string::String::new())
    }

    pub fn get_custom_id(&self) -> &str {
        &self.custom_id
    }

    // .google.protobuf.Timestamp verify_time = 6;

    pub fn clear_verify_time(&mut self) {
        self.verify_time.clear();
    }

    pub fn has_verify_time(&self) -> bool {
        self.verify_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verify_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.verify_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verify_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.verify_time.is_none() {
            self.verify_time.set_default();
        }
        self.verify_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_verify_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.verify_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_verify_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.verify_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for Account {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verify_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.wallet)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verify_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.wallet.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.wallet);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.email);
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.custom_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.custom_id);
        }
        if let Some(ref v) = self.verify_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.wallet.is_empty() {
            os.write_string(2, &self.wallet)?;
        }
        if !self.email.is_empty() {
            os.write_string(3, &self.email)?;
        }
        for v in &self.devices {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.custom_id.is_empty() {
            os.write_string(5, &self.custom_id)?;
        }
        if let Some(ref v) = self.verify_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account {
        Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &Account| { &m.user },
                    |m: &mut Account| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wallet",
                    |m: &Account| { &m.wallet },
                    |m: &mut Account| { &mut m.wallet },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "email",
                    |m: &Account| { &m.email },
                    |m: &mut Account| { &mut m.email },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountDevice>>(
                    "devices",
                    |m: &Account| { &m.devices },
                    |m: &mut Account| { &mut m.devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "custom_id",
                    |m: &Account| { &m.custom_id },
                    |m: &mut Account| { &mut m.custom_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "verify_time",
                    |m: &Account| { &m.verify_time },
                    |m: &mut Account| { &mut m.verify_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Account>(
                    "Account",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Account {
        static mut instance: ::protobuf::lazy::Lazy<Account> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Account,
        };
        unsafe {
            instance.get(Account::new)
        }
    }
}

impl ::protobuf::Clear for Account {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_wallet();
        self.clear_email();
        self.clear_devices();
        self.clear_custom_id();
        self.clear_verify_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountCustom {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountCustom {
    pub fn new() -> AccountCustom {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }
}

impl ::protobuf::Message for AccountCustom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountCustom {
        AccountCustom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &AccountCustom| { &m.id },
                    |m: &mut AccountCustom| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountCustom>(
                    "AccountCustom",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountCustom {
        static mut instance: ::protobuf::lazy::Lazy<AccountCustom> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountCustom,
        };
        unsafe {
            instance.get(AccountCustom::new)
        }
    }
}

impl ::protobuf::Clear for AccountCustom {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountCustom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountCustom {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountDevice {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountDevice {
    pub fn new() -> AccountDevice {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }
}

impl ::protobuf::Message for AccountDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountDevice {
        AccountDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &AccountDevice| { &m.id },
                    |m: &mut AccountDevice| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountDevice>(
                    "AccountDevice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountDevice {
        static mut instance: ::protobuf::lazy::Lazy<AccountDevice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountDevice,
        };
        unsafe {
            instance.get(AccountDevice::new)
        }
    }
}

impl ::protobuf::Clear for AccountDevice {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountEmail {
    // message fields
    pub email: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountEmail {
    pub fn new() -> AccountEmail {
        ::std::default::Default::default()
    }

    // string email = 1;

    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    pub fn get_email(&self) -> &str {
        &self.email
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for AccountEmail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountEmail {
        AccountEmail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "email",
                    |m: &AccountEmail| { &m.email },
                    |m: &mut AccountEmail| { &mut m.email },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &AccountEmail| { &m.password },
                    |m: &mut AccountEmail| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountEmail>(
                    "AccountEmail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountEmail {
        static mut instance: ::protobuf::lazy::Lazy<AccountEmail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountEmail,
        };
        unsafe {
            instance.get(AccountEmail::new)
        }
    }
}

impl ::protobuf::Clear for AccountEmail {
    fn clear(&mut self) {
        self.clear_email();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountEmail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountEmail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountFacebook {
    // message fields
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountFacebook {
    pub fn new() -> AccountFacebook {
        ::std::default::Default::default()
    }

    // string token = 1;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    pub fn get_token(&self) -> &str {
        &self.token
    }
}

impl ::protobuf::Message for AccountFacebook {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountFacebook {
        AccountFacebook::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &AccountFacebook| { &m.token },
                    |m: &mut AccountFacebook| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountFacebook>(
                    "AccountFacebook",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountFacebook {
        static mut instance: ::protobuf::lazy::Lazy<AccountFacebook> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountFacebook,
        };
        unsafe {
            instance.get(AccountFacebook::new)
        }
    }
}

impl ::protobuf::Clear for AccountFacebook {
    fn clear(&mut self) {
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountFacebook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountFacebook {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountGameCenter {
    // message fields
    pub player_id: ::std::string::String,
    pub bundle_id: ::std::string::String,
    pub timestamp_seconds: i64,
    pub salt: ::std::string::String,
    pub signature: ::std::string::String,
    pub public_key_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountGameCenter {
    pub fn new() -> AccountGameCenter {
        ::std::default::Default::default()
    }

    // string player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: ::std::string::String) {
        self.player_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_id(&mut self) -> &mut ::std::string::String {
        &mut self.player_id
    }

    // Take field
    pub fn take_player_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.player_id, ::std::string::String::new())
    }

    pub fn get_player_id(&self) -> &str {
        &self.player_id
    }

    // string bundle_id = 2;

    pub fn clear_bundle_id(&mut self) {
        self.bundle_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_bundle_id(&mut self, v: ::std::string::String) {
        self.bundle_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bundle_id(&mut self) -> &mut ::std::string::String {
        &mut self.bundle_id
    }

    // Take field
    pub fn take_bundle_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bundle_id, ::std::string::String::new())
    }

    pub fn get_bundle_id(&self) -> &str {
        &self.bundle_id
    }

    // int64 timestamp_seconds = 3;

    pub fn clear_timestamp_seconds(&mut self) {
        self.timestamp_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_seconds(&mut self, v: i64) {
        self.timestamp_seconds = v;
    }

    pub fn get_timestamp_seconds(&self) -> i64 {
        self.timestamp_seconds
    }

    // string salt = 4;

    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::string::String) {
        self.salt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::string::String {
        &mut self.salt
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.salt, ::std::string::String::new())
    }

    pub fn get_salt(&self) -> &str {
        &self.salt
    }

    // string signature = 5;

    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }

    pub fn get_signature(&self) -> &str {
        &self.signature
    }

    // string public_key_url = 6;

    pub fn clear_public_key_url(&mut self) {
        self.public_key_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key_url(&mut self, v: ::std::string::String) {
        self.public_key_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key_url(&mut self) -> &mut ::std::string::String {
        &mut self.public_key_url
    }

    // Take field
    pub fn take_public_key_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.public_key_url, ::std::string::String::new())
    }

    pub fn get_public_key_url(&self) -> &str {
        &self.public_key_url
    }
}

impl ::protobuf::Message for AccountGameCenter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.player_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bundle_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp_seconds = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.salt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.public_key_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.player_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.player_id);
        }
        if !self.bundle_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bundle_id);
        }
        if self.timestamp_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.salt);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signature);
        }
        if !self.public_key_url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.public_key_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.player_id.is_empty() {
            os.write_string(1, &self.player_id)?;
        }
        if !self.bundle_id.is_empty() {
            os.write_string(2, &self.bundle_id)?;
        }
        if self.timestamp_seconds != 0 {
            os.write_int64(3, self.timestamp_seconds)?;
        }
        if !self.salt.is_empty() {
            os.write_string(4, &self.salt)?;
        }
        if !self.signature.is_empty() {
            os.write_string(5, &self.signature)?;
        }
        if !self.public_key_url.is_empty() {
            os.write_string(6, &self.public_key_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountGameCenter {
        AccountGameCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_id",
                    |m: &AccountGameCenter| { &m.player_id },
                    |m: &mut AccountGameCenter| { &mut m.player_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bundle_id",
                    |m: &AccountGameCenter| { &m.bundle_id },
                    |m: &mut AccountGameCenter| { &mut m.bundle_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp_seconds",
                    |m: &AccountGameCenter| { &m.timestamp_seconds },
                    |m: &mut AccountGameCenter| { &mut m.timestamp_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "salt",
                    |m: &AccountGameCenter| { &m.salt },
                    |m: &mut AccountGameCenter| { &mut m.salt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &AccountGameCenter| { &m.signature },
                    |m: &mut AccountGameCenter| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "public_key_url",
                    |m: &AccountGameCenter| { &m.public_key_url },
                    |m: &mut AccountGameCenter| { &mut m.public_key_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountGameCenter>(
                    "AccountGameCenter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountGameCenter {
        static mut instance: ::protobuf::lazy::Lazy<AccountGameCenter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountGameCenter,
        };
        unsafe {
            instance.get(AccountGameCenter::new)
        }
    }
}

impl ::protobuf::Clear for AccountGameCenter {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_bundle_id();
        self.clear_timestamp_seconds();
        self.clear_salt();
        self.clear_signature();
        self.clear_public_key_url();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountGameCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountGameCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountGoogle {
    // message fields
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountGoogle {
    pub fn new() -> AccountGoogle {
        ::std::default::Default::default()
    }

    // string token = 1;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    pub fn get_token(&self) -> &str {
        &self.token
    }
}

impl ::protobuf::Message for AccountGoogle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountGoogle {
        AccountGoogle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &AccountGoogle| { &m.token },
                    |m: &mut AccountGoogle| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountGoogle>(
                    "AccountGoogle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountGoogle {
        static mut instance: ::protobuf::lazy::Lazy<AccountGoogle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountGoogle,
        };
        unsafe {
            instance.get(AccountGoogle::new)
        }
    }
}

impl ::protobuf::Clear for AccountGoogle {
    fn clear(&mut self) {
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountGoogle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountGoogle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountSteam {
    // message fields
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountSteam {
    pub fn new() -> AccountSteam {
        ::std::default::Default::default()
    }

    // string token = 1;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    pub fn get_token(&self) -> &str {
        &self.token
    }
}

impl ::protobuf::Message for AccountSteam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountSteam {
        AccountSteam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &AccountSteam| { &m.token },
                    |m: &mut AccountSteam| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountSteam>(
                    "AccountSteam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountSteam {
        static mut instance: ::protobuf::lazy::Lazy<AccountSteam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountSteam,
        };
        unsafe {
            instance.get(AccountSteam::new)
        }
    }
}

impl ::protobuf::Clear for AccountSteam {
    fn clear(&mut self) {
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountSteam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountSteam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddFriendsRequest {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub usernames: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddFriendsRequest {
    pub fn new() -> AddFriendsRequest {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }

    // repeated string usernames = 2;

    pub fn clear_usernames(&mut self) {
        self.usernames.clear();
    }

    // Param is passed by value, moved
    pub fn set_usernames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usernames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usernames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usernames
    }

    // Take field
    pub fn take_usernames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usernames, ::protobuf::RepeatedField::new())
    }

    pub fn get_usernames(&self) -> &[::std::string::String] {
        &self.usernames
    }
}

impl ::protobuf::Message for AddFriendsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usernames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.usernames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        for v in &self.usernames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddFriendsRequest {
        AddFriendsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &AddFriendsRequest| { &m.ids },
                    |m: &mut AddFriendsRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "usernames",
                    |m: &AddFriendsRequest| { &m.usernames },
                    |m: &mut AddFriendsRequest| { &mut m.usernames },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddFriendsRequest>(
                    "AddFriendsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddFriendsRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddFriendsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddFriendsRequest,
        };
        unsafe {
            instance.get(AddFriendsRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddFriendsRequest {
    fn clear(&mut self) {
        self.clear_ids();
        self.clear_usernames();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddFriendsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddFriendsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddGroupUsersRequest {
    // message fields
    pub group_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddGroupUsersRequest {
    pub fn new() -> AddGroupUsersRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }

    // repeated string user_ids = 2;

    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
}

impl ::protobuf::Message for AddGroupUsersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddGroupUsersRequest {
        AddGroupUsersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &AddGroupUsersRequest| { &m.group_id },
                    |m: &mut AddGroupUsersRequest| { &mut m.group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_ids",
                    |m: &AddGroupUsersRequest| { &m.user_ids },
                    |m: &mut AddGroupUsersRequest| { &mut m.user_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddGroupUsersRequest>(
                    "AddGroupUsersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddGroupUsersRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddGroupUsersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddGroupUsersRequest,
        };
        unsafe {
            instance.get(AddGroupUsersRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddGroupUsersRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.clear_user_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddGroupUsersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddGroupUsersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateCustomRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountCustom>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateCustomRequest {
    pub fn new() -> AuthenticateCustomRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountCustom account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountCustom) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountCustom {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountCustom {
        self.account.take().unwrap_or_else(|| AccountCustom::new())
    }

    pub fn get_account(&self) -> &AccountCustom {
        self.account.as_ref().unwrap_or_else(|| AccountCustom::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateCustomRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateCustomRequest {
        AuthenticateCustomRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountCustom>>(
                    "account",
                    |m: &AuthenticateCustomRequest| { &m.account },
                    |m: &mut AuthenticateCustomRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateCustomRequest| { &m.create },
                    |m: &mut AuthenticateCustomRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateCustomRequest| { &m.username },
                    |m: &mut AuthenticateCustomRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateCustomRequest>(
                    "AuthenticateCustomRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateCustomRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateCustomRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateCustomRequest,
        };
        unsafe {
            instance.get(AuthenticateCustomRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateCustomRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateCustomRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateCustomRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateDeviceRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountDevice>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateDeviceRequest {
    pub fn new() -> AuthenticateDeviceRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountDevice account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountDevice) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountDevice {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountDevice {
        self.account.take().unwrap_or_else(|| AccountDevice::new())
    }

    pub fn get_account(&self) -> &AccountDevice {
        self.account.as_ref().unwrap_or_else(|| AccountDevice::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateDeviceRequest {
        AuthenticateDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountDevice>>(
                    "account",
                    |m: &AuthenticateDeviceRequest| { &m.account },
                    |m: &mut AuthenticateDeviceRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateDeviceRequest| { &m.create },
                    |m: &mut AuthenticateDeviceRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateDeviceRequest| { &m.username },
                    |m: &mut AuthenticateDeviceRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateDeviceRequest>(
                    "AuthenticateDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateDeviceRequest,
        };
        unsafe {
            instance.get(AuthenticateDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateDeviceRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateEmailRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountEmail>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateEmailRequest {
    pub fn new() -> AuthenticateEmailRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountEmail account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountEmail) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountEmail {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountEmail {
        self.account.take().unwrap_or_else(|| AccountEmail::new())
    }

    pub fn get_account(&self) -> &AccountEmail {
        self.account.as_ref().unwrap_or_else(|| AccountEmail::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateEmailRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateEmailRequest {
        AuthenticateEmailRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountEmail>>(
                    "account",
                    |m: &AuthenticateEmailRequest| { &m.account },
                    |m: &mut AuthenticateEmailRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateEmailRequest| { &m.create },
                    |m: &mut AuthenticateEmailRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateEmailRequest| { &m.username },
                    |m: &mut AuthenticateEmailRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateEmailRequest>(
                    "AuthenticateEmailRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateEmailRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateEmailRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateEmailRequest,
        };
        unsafe {
            instance.get(AuthenticateEmailRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateEmailRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateEmailRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateEmailRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateFacebookRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountFacebook>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    pub sync: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateFacebookRequest {
    pub fn new() -> AuthenticateFacebookRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountFacebook account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountFacebook) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountFacebook {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountFacebook {
        self.account.take().unwrap_or_else(|| AccountFacebook::new())
    }

    pub fn get_account(&self) -> &AccountFacebook {
        self.account.as_ref().unwrap_or_else(|| AccountFacebook::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // .google.protobuf.BoolValue sync = 4;

    pub fn clear_sync(&mut self) {
        self.sync.clear();
    }

    pub fn has_sync(&self) -> bool {
        self.sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.sync = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sync(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.sync.is_none() {
            self.sync.set_default();
        }
        self.sync.as_mut().unwrap()
    }

    // Take field
    pub fn take_sync(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.sync.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_sync(&self) -> &::protobuf::well_known_types::BoolValue {
        self.sync.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for AuthenticateFacebookRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sync {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sync)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        if let Some(ref v) = self.sync.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        if let Some(ref v) = self.sync.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateFacebookRequest {
        AuthenticateFacebookRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountFacebook>>(
                    "account",
                    |m: &AuthenticateFacebookRequest| { &m.account },
                    |m: &mut AuthenticateFacebookRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateFacebookRequest| { &m.create },
                    |m: &mut AuthenticateFacebookRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateFacebookRequest| { &m.username },
                    |m: &mut AuthenticateFacebookRequest| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "sync",
                    |m: &AuthenticateFacebookRequest| { &m.sync },
                    |m: &mut AuthenticateFacebookRequest| { &mut m.sync },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateFacebookRequest>(
                    "AuthenticateFacebookRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateFacebookRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateFacebookRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateFacebookRequest,
        };
        unsafe {
            instance.get(AuthenticateFacebookRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateFacebookRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.clear_sync();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateFacebookRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateFacebookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateGameCenterRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountGameCenter>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateGameCenterRequest {
    pub fn new() -> AuthenticateGameCenterRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountGameCenter account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountGameCenter) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountGameCenter {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountGameCenter {
        self.account.take().unwrap_or_else(|| AccountGameCenter::new())
    }

    pub fn get_account(&self) -> &AccountGameCenter {
        self.account.as_ref().unwrap_or_else(|| AccountGameCenter::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateGameCenterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateGameCenterRequest {
        AuthenticateGameCenterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountGameCenter>>(
                    "account",
                    |m: &AuthenticateGameCenterRequest| { &m.account },
                    |m: &mut AuthenticateGameCenterRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateGameCenterRequest| { &m.create },
                    |m: &mut AuthenticateGameCenterRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateGameCenterRequest| { &m.username },
                    |m: &mut AuthenticateGameCenterRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateGameCenterRequest>(
                    "AuthenticateGameCenterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateGameCenterRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateGameCenterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateGameCenterRequest,
        };
        unsafe {
            instance.get(AuthenticateGameCenterRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateGameCenterRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateGameCenterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateGameCenterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateGoogleRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountGoogle>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateGoogleRequest {
    pub fn new() -> AuthenticateGoogleRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountGoogle account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountGoogle) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountGoogle {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountGoogle {
        self.account.take().unwrap_or_else(|| AccountGoogle::new())
    }

    pub fn get_account(&self) -> &AccountGoogle {
        self.account.as_ref().unwrap_or_else(|| AccountGoogle::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateGoogleRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateGoogleRequest {
        AuthenticateGoogleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountGoogle>>(
                    "account",
                    |m: &AuthenticateGoogleRequest| { &m.account },
                    |m: &mut AuthenticateGoogleRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateGoogleRequest| { &m.create },
                    |m: &mut AuthenticateGoogleRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateGoogleRequest| { &m.username },
                    |m: &mut AuthenticateGoogleRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateGoogleRequest>(
                    "AuthenticateGoogleRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateGoogleRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateGoogleRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateGoogleRequest,
        };
        unsafe {
            instance.get(AuthenticateGoogleRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateGoogleRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateGoogleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateGoogleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateSteamRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountSteam>,
    pub create: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuthenticateSteamRequest {
    pub fn new() -> AuthenticateSteamRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountSteam account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountSteam) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountSteam {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountSteam {
        self.account.take().unwrap_or_else(|| AccountSteam::new())
    }

    pub fn get_account(&self) -> &AccountSteam {
        self.account.as_ref().unwrap_or_else(|| AccountSteam::default_instance())
    }

    // .google.protobuf.BoolValue create = 2;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.create.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_create(&self) -> &::protobuf::well_known_types::BoolValue {
        self.create.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }
}

impl ::protobuf::Message for AuthenticateSteamRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateSteamRequest {
        AuthenticateSteamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountSteam>>(
                    "account",
                    |m: &AuthenticateSteamRequest| { &m.account },
                    |m: &mut AuthenticateSteamRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "create",
                    |m: &AuthenticateSteamRequest| { &m.create },
                    |m: &mut AuthenticateSteamRequest| { &mut m.create },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &AuthenticateSteamRequest| { &m.username },
                    |m: &mut AuthenticateSteamRequest| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthenticateSteamRequest>(
                    "AuthenticateSteamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuthenticateSteamRequest {
        static mut instance: ::protobuf::lazy::Lazy<AuthenticateSteamRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuthenticateSteamRequest,
        };
        unsafe {
            instance.get(AuthenticateSteamRequest::new)
        }
    }
}

impl ::protobuf::Clear for AuthenticateSteamRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_create();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateSteamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateSteamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockFriendsRequest {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub usernames: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BlockFriendsRequest {
    pub fn new() -> BlockFriendsRequest {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }

    // repeated string usernames = 2;

    pub fn clear_usernames(&mut self) {
        self.usernames.clear();
    }

    // Param is passed by value, moved
    pub fn set_usernames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usernames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usernames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usernames
    }

    // Take field
    pub fn take_usernames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usernames, ::protobuf::RepeatedField::new())
    }

    pub fn get_usernames(&self) -> &[::std::string::String] {
        &self.usernames
    }
}

impl ::protobuf::Message for BlockFriendsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usernames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.usernames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        for v in &self.usernames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockFriendsRequest {
        BlockFriendsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &BlockFriendsRequest| { &m.ids },
                    |m: &mut BlockFriendsRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "usernames",
                    |m: &BlockFriendsRequest| { &m.usernames },
                    |m: &mut BlockFriendsRequest| { &mut m.usernames },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockFriendsRequest>(
                    "BlockFriendsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockFriendsRequest {
        static mut instance: ::protobuf::lazy::Lazy<BlockFriendsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockFriendsRequest,
        };
        unsafe {
            instance.get(BlockFriendsRequest::new)
        }
    }
}

impl ::protobuf::Clear for BlockFriendsRequest {
    fn clear(&mut self) {
        self.clear_ids();
        self.clear_usernames();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockFriendsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockFriendsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessage {
    // message fields
    pub channel_id: ::std::string::String,
    pub message_id: ::std::string::String,
    pub code: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub sender_id: ::std::string::String,
    pub username: ::std::string::String,
    pub content: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub persistent: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessage {
    pub fn new() -> ChannelMessage {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // string message_id = 2;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }

    // .google.protobuf.Int32Value code = 3;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.code.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_code(&self) -> &::protobuf::well_known_types::Int32Value {
        self.code.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string sender_id = 4;

    pub fn clear_sender_id(&mut self) {
        self.sender_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: ::std::string::String) {
        self.sender_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_id(&mut self) -> &mut ::std::string::String {
        &mut self.sender_id
    }

    // Take field
    pub fn take_sender_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender_id, ::std::string::String::new())
    }

    pub fn get_sender_id(&self) -> &str {
        &self.sender_id
    }

    // string username = 5;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // string content = 6;

    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    pub fn get_content(&self) -> &str {
        &self.content
    }

    // .google.protobuf.Timestamp create_time = 7;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 8;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.BoolValue persistent = 9;

    pub fn clear_persistent(&mut self) {
        self.persistent.clear();
    }

    pub fn has_persistent(&self) -> bool {
        self.persistent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.persistent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistent(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.persistent.is_none() {
            self.persistent.set_default();
        }
        self.persistent.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistent(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.persistent.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_persistent(&self) -> &::protobuf::well_known_types::BoolValue {
        self.persistent.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for ChannelMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.persistent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message_id);
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sender_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sender_id);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.username);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.content);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.message_id.is_empty() {
            os.write_string(2, &self.message_id)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sender_id.is_empty() {
            os.write_string(4, &self.sender_id)?;
        }
        if !self.username.is_empty() {
            os.write_string(5, &self.username)?;
        }
        if !self.content.is_empty() {
            os.write_string(6, &self.content)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistent.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessage {
        ChannelMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ChannelMessage| { &m.channel_id },
                    |m: &mut ChannelMessage| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &ChannelMessage| { &m.message_id },
                    |m: &mut ChannelMessage| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "code",
                    |m: &ChannelMessage| { &m.code },
                    |m: &mut ChannelMessage| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender_id",
                    |m: &ChannelMessage| { &m.sender_id },
                    |m: &mut ChannelMessage| { &mut m.sender_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &ChannelMessage| { &m.username },
                    |m: &mut ChannelMessage| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &ChannelMessage| { &m.content },
                    |m: &mut ChannelMessage| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &ChannelMessage| { &m.create_time },
                    |m: &mut ChannelMessage| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &ChannelMessage| { &m.update_time },
                    |m: &mut ChannelMessage| { &mut m.update_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "persistent",
                    |m: &ChannelMessage| { &m.persistent },
                    |m: &mut ChannelMessage| { &mut m.persistent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessage>(
                    "ChannelMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessage {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessage,
        };
        unsafe {
            instance.get(ChannelMessage::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessage {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_message_id();
        self.clear_code();
        self.clear_sender_id();
        self.clear_username();
        self.clear_content();
        self.clear_create_time();
        self.clear_update_time();
        self.clear_persistent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelMessageList {
    // message fields
    pub messages: ::protobuf::RepeatedField<ChannelMessage>,
    pub next_cursor: ::std::string::String,
    pub prev_cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChannelMessageList {
    pub fn new() -> ChannelMessageList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.ChannelMessage messages = 1;

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<ChannelMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<ChannelMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<ChannelMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    pub fn get_messages(&self) -> &[ChannelMessage] {
        &self.messages
    }

    // string next_cursor = 2;

    pub fn clear_next_cursor(&mut self) {
        self.next_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_cursor(&mut self, v: ::std::string::String) {
        self.next_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.next_cursor
    }

    // Take field
    pub fn take_next_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_cursor, ::std::string::String::new())
    }

    pub fn get_next_cursor(&self) -> &str {
        &self.next_cursor
    }

    // string prev_cursor = 3;

    pub fn clear_prev_cursor(&mut self) {
        self.prev_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_cursor(&mut self, v: ::std::string::String) {
        self.prev_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.prev_cursor
    }

    // Take field
    pub fn take_prev_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prev_cursor, ::std::string::String::new())
    }

    pub fn get_prev_cursor(&self) -> &str {
        &self.prev_cursor
    }
}

impl ::protobuf::Message for ChannelMessageList {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prev_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_cursor);
        }
        if !self.prev_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.prev_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_cursor.is_empty() {
            os.write_string(2, &self.next_cursor)?;
        }
        if !self.prev_cursor.is_empty() {
            os.write_string(3, &self.prev_cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelMessageList {
        ChannelMessageList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelMessage>>(
                    "messages",
                    |m: &ChannelMessageList| { &m.messages },
                    |m: &mut ChannelMessageList| { &mut m.messages },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_cursor",
                    |m: &ChannelMessageList| { &m.next_cursor },
                    |m: &mut ChannelMessageList| { &mut m.next_cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prev_cursor",
                    |m: &ChannelMessageList| { &m.prev_cursor },
                    |m: &mut ChannelMessageList| { &mut m.prev_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelMessageList>(
                    "ChannelMessageList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelMessageList {
        static mut instance: ::protobuf::lazy::Lazy<ChannelMessageList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelMessageList,
        };
        unsafe {
            instance.get(ChannelMessageList::new)
        }
    }
}

impl ::protobuf::Clear for ChannelMessageList {
    fn clear(&mut self) {
        self.clear_messages();
        self.clear_next_cursor();
        self.clear_prev_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelMessageList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelMessageList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateGroupRequest {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub lang_tag: ::std::string::String,
    pub avatar_url: ::std::string::String,
    pub open: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CreateGroupRequest {
    pub fn new() -> CreateGroupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string description = 2;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string lang_tag = 3;

    pub fn clear_lang_tag(&mut self) {
        self.lang_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_lang_tag(&mut self, v: ::std::string::String) {
        self.lang_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang_tag(&mut self) -> &mut ::std::string::String {
        &mut self.lang_tag
    }

    // Take field
    pub fn take_lang_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lang_tag, ::std::string::String::new())
    }

    pub fn get_lang_tag(&self) -> &str {
        &self.lang_tag
    }

    // string avatar_url = 4;

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        &mut self.avatar_url
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar_url, ::std::string::String::new())
    }

    pub fn get_avatar_url(&self) -> &str {
        &self.avatar_url
    }

    // bool open = 5;

    pub fn clear_open(&mut self) {
        self.open = false;
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = v;
    }

    pub fn get_open(&self) -> bool {
        self.open
    }
}

impl ::protobuf::Message for CreateGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lang_tag)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.open = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.lang_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.lang_tag);
        }
        if !self.avatar_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.avatar_url);
        }
        if self.open != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.lang_tag.is_empty() {
            os.write_string(3, &self.lang_tag)?;
        }
        if !self.avatar_url.is_empty() {
            os.write_string(4, &self.avatar_url)?;
        }
        if self.open != false {
            os.write_bool(5, self.open)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateGroupRequest {
        CreateGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateGroupRequest| { &m.name },
                    |m: &mut CreateGroupRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &CreateGroupRequest| { &m.description },
                    |m: &mut CreateGroupRequest| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lang_tag",
                    |m: &CreateGroupRequest| { &m.lang_tag },
                    |m: &mut CreateGroupRequest| { &mut m.lang_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "avatar_url",
                    |m: &CreateGroupRequest| { &m.avatar_url },
                    |m: &mut CreateGroupRequest| { &mut m.avatar_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "open",
                    |m: &CreateGroupRequest| { &m.open },
                    |m: &mut CreateGroupRequest| { &mut m.open },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateGroupRequest>(
                    "CreateGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateGroupRequest,
        };
        unsafe {
            instance.get(CreateGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateGroupRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_description();
        self.clear_lang_tag();
        self.clear_avatar_url();
        self.clear_open();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteFriendsRequest {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub usernames: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteFriendsRequest {
    pub fn new() -> DeleteFriendsRequest {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }

    // repeated string usernames = 2;

    pub fn clear_usernames(&mut self) {
        self.usernames.clear();
    }

    // Param is passed by value, moved
    pub fn set_usernames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usernames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usernames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usernames
    }

    // Take field
    pub fn take_usernames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usernames, ::protobuf::RepeatedField::new())
    }

    pub fn get_usernames(&self) -> &[::std::string::String] {
        &self.usernames
    }
}

impl ::protobuf::Message for DeleteFriendsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usernames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.usernames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        for v in &self.usernames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteFriendsRequest {
        DeleteFriendsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &DeleteFriendsRequest| { &m.ids },
                    |m: &mut DeleteFriendsRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "usernames",
                    |m: &DeleteFriendsRequest| { &m.usernames },
                    |m: &mut DeleteFriendsRequest| { &mut m.usernames },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteFriendsRequest>(
                    "DeleteFriendsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteFriendsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteFriendsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteFriendsRequest,
        };
        unsafe {
            instance.get(DeleteFriendsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteFriendsRequest {
    fn clear(&mut self) {
        self.clear_ids();
        self.clear_usernames();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteFriendsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFriendsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteGroupRequest {
    // message fields
    pub group_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteGroupRequest {
    pub fn new() -> DeleteGroupRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }
}

impl ::protobuf::Message for DeleteGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteGroupRequest {
        DeleteGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &DeleteGroupRequest| { &m.group_id },
                    |m: &mut DeleteGroupRequest| { &mut m.group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteGroupRequest>(
                    "DeleteGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteGroupRequest,
        };
        unsafe {
            instance.get(DeleteGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteGroupRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteLeaderboardRecordRequest {
    // message fields
    pub leaderboard_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteLeaderboardRecordRequest {
    pub fn new() -> DeleteLeaderboardRecordRequest {
        ::std::default::Default::default()
    }

    // string leaderboard_id = 1;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: ::std::string::String) {
        self.leaderboard_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_id(&mut self) -> &mut ::std::string::String {
        &mut self.leaderboard_id
    }

    // Take field
    pub fn take_leaderboard_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaderboard_id, ::std::string::String::new())
    }

    pub fn get_leaderboard_id(&self) -> &str {
        &self.leaderboard_id
    }
}

impl ::protobuf::Message for DeleteLeaderboardRecordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.leaderboard_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.leaderboard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.leaderboard_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.leaderboard_id.is_empty() {
            os.write_string(1, &self.leaderboard_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteLeaderboardRecordRequest {
        DeleteLeaderboardRecordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "leaderboard_id",
                    |m: &DeleteLeaderboardRecordRequest| { &m.leaderboard_id },
                    |m: &mut DeleteLeaderboardRecordRequest| { &mut m.leaderboard_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteLeaderboardRecordRequest>(
                    "DeleteLeaderboardRecordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteLeaderboardRecordRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteLeaderboardRecordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteLeaderboardRecordRequest,
        };
        unsafe {
            instance.get(DeleteLeaderboardRecordRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteLeaderboardRecordRequest {
    fn clear(&mut self) {
        self.clear_leaderboard_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteLeaderboardRecordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLeaderboardRecordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteNotificationsRequest {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteNotificationsRequest {
    pub fn new() -> DeleteNotificationsRequest {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
}

impl ::protobuf::Message for DeleteNotificationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNotificationsRequest {
        DeleteNotificationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &DeleteNotificationsRequest| { &m.ids },
                    |m: &mut DeleteNotificationsRequest| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteNotificationsRequest>(
                    "DeleteNotificationsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteNotificationsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteNotificationsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteNotificationsRequest,
        };
        unsafe {
            instance.get(DeleteNotificationsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteNotificationsRequest {
    fn clear(&mut self) {
        self.clear_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNotificationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNotificationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteStorageObjectId {
    // message fields
    pub collection: ::std::string::String,
    pub key: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteStorageObjectId {
    pub fn new() -> DeleteStorageObjectId {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        &self.key
    }

    // string version = 3;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }
}

impl ::protobuf::Message for DeleteStorageObjectId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteStorageObjectId {
        DeleteStorageObjectId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &DeleteStorageObjectId| { &m.collection },
                    |m: &mut DeleteStorageObjectId| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &DeleteStorageObjectId| { &m.key },
                    |m: &mut DeleteStorageObjectId| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &DeleteStorageObjectId| { &m.version },
                    |m: &mut DeleteStorageObjectId| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteStorageObjectId>(
                    "DeleteStorageObjectId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteStorageObjectId {
        static mut instance: ::protobuf::lazy::Lazy<DeleteStorageObjectId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteStorageObjectId,
        };
        unsafe {
            instance.get(DeleteStorageObjectId::new)
        }
    }
}

impl ::protobuf::Clear for DeleteStorageObjectId {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_key();
        self.clear_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteStorageObjectId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStorageObjectId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteStorageObjectsRequest {
    // message fields
    pub object_ids: ::protobuf::RepeatedField<DeleteStorageObjectId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeleteStorageObjectsRequest {
    pub fn new() -> DeleteStorageObjectsRequest {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.DeleteStorageObjectId object_ids = 1;

    pub fn clear_object_ids(&mut self) {
        self.object_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_ids(&mut self, v: ::protobuf::RepeatedField<DeleteStorageObjectId>) {
        self.object_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_ids(&mut self) -> &mut ::protobuf::RepeatedField<DeleteStorageObjectId> {
        &mut self.object_ids
    }

    // Take field
    pub fn take_object_ids(&mut self) -> ::protobuf::RepeatedField<DeleteStorageObjectId> {
        ::std::mem::replace(&mut self.object_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_object_ids(&self) -> &[DeleteStorageObjectId] {
        &self.object_ids
    }
}

impl ::protobuf::Message for DeleteStorageObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.object_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.object_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.object_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteStorageObjectsRequest {
        DeleteStorageObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeleteStorageObjectId>>(
                    "object_ids",
                    |m: &DeleteStorageObjectsRequest| { &m.object_ids },
                    |m: &mut DeleteStorageObjectsRequest| { &mut m.object_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteStorageObjectsRequest>(
                    "DeleteStorageObjectsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteStorageObjectsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteStorageObjectsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteStorageObjectsRequest,
        };
        unsafe {
            instance.get(DeleteStorageObjectsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteStorageObjectsRequest {
    fn clear(&mut self) {
        self.clear_object_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteStorageObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStorageObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub name: ::std::string::String,
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // repeated .nakama.api.Event.PropertiesEntry properties = 2;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.properties, ::std::collections::HashMap::new())
    }

    pub fn get_properties(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.properties
    }

    // .google.protobuf.Timestamp timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.timestamp.is_none() {
            self.timestamp.set_default();
        }
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.timestamp.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.properties)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.properties);
        if let Some(ref v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.properties, os)?;
        if let Some(ref v) = self.timestamp.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Event| { &m.name },
                    |m: &mut Event| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "properties",
                    |m: &Event| { &m.properties },
                    |m: &mut Event| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "timestamp",
                    |m: &Event| { &m.timestamp },
                    |m: &mut Event| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event>(
                    "Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event,
        };
        unsafe {
            instance.get(Event::new)
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_properties();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Friend {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    pub state: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Friend {
    pub fn new() -> Friend {
        ::std::default::Default::default()
    }

    // .nakama.api.User user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }

    // .google.protobuf.Int32Value state = 2;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.state.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_state(&self) -> &::protobuf::well_known_types::Int32Value {
        self.state.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for Friend {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Friend {
        Friend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &Friend| { &m.user },
                    |m: &mut Friend| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "state",
                    |m: &Friend| { &m.state },
                    |m: &mut Friend| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Friend>(
                    "Friend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Friend {
        static mut instance: ::protobuf::lazy::Lazy<Friend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Friend,
        };
        unsafe {
            instance.get(Friend::new)
        }
    }
}

impl ::protobuf::Clear for Friend {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Friend {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Friend_State {
    FRIEND = 0,
    INVITE_SENT = 1,
    INVITE_RECEIVED = 2,
    BLOCKED = 3,
}

impl ::protobuf::ProtobufEnum for Friend_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Friend_State> {
        match value {
            0 => ::std::option::Option::Some(Friend_State::FRIEND),
            1 => ::std::option::Option::Some(Friend_State::INVITE_SENT),
            2 => ::std::option::Option::Some(Friend_State::INVITE_RECEIVED),
            3 => ::std::option::Option::Some(Friend_State::BLOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Friend_State] = &[
            Friend_State::FRIEND,
            Friend_State::INVITE_SENT,
            Friend_State::INVITE_RECEIVED,
            Friend_State::BLOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Friend_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Friend_State {
}

impl ::std::default::Default for Friend_State {
    fn default() -> Self {
        Friend_State::FRIEND
    }
}

impl ::protobuf::reflect::ProtobufValue for Friend_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Friends {
    // message fields
    pub friends: ::protobuf::RepeatedField<Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Friends {
    pub fn new() -> Friends {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Friend friends = 1;

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }

    pub fn get_friends(&self) -> &[Friend] {
        &self.friends
    }
}

impl ::protobuf::Message for Friends {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.friends {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Friends {
        Friends::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Friend>>(
                    "friends",
                    |m: &Friends| { &m.friends },
                    |m: &mut Friends| { &mut m.friends },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Friends>(
                    "Friends",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Friends {
        static mut instance: ::protobuf::lazy::Lazy<Friends> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Friends,
        };
        unsafe {
            instance.get(Friends::new)
        }
    }
}

impl ::protobuf::Clear for Friends {
    fn clear(&mut self) {
        self.clear_friends();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Friends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Friends {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUsersRequest {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub usernames: ::protobuf::RepeatedField<::std::string::String>,
    pub facebook_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GetUsersRequest {
    pub fn new() -> GetUsersRequest {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }

    // repeated string usernames = 2;

    pub fn clear_usernames(&mut self) {
        self.usernames.clear();
    }

    // Param is passed by value, moved
    pub fn set_usernames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usernames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usernames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usernames
    }

    // Take field
    pub fn take_usernames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usernames, ::protobuf::RepeatedField::new())
    }

    pub fn get_usernames(&self) -> &[::std::string::String] {
        &self.usernames
    }

    // repeated string facebook_ids = 3;

    pub fn clear_facebook_ids(&mut self) {
        self.facebook_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_facebook_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.facebook_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_facebook_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.facebook_ids
    }

    // Take field
    pub fn take_facebook_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.facebook_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_facebook_ids(&self) -> &[::std::string::String] {
        &self.facebook_ids
    }
}

impl ::protobuf::Message for GetUsersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usernames)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.facebook_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.usernames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.facebook_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        for v in &self.usernames {
            os.write_string(2, &v)?;
        };
        for v in &self.facebook_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUsersRequest {
        GetUsersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &GetUsersRequest| { &m.ids },
                    |m: &mut GetUsersRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "usernames",
                    |m: &GetUsersRequest| { &m.usernames },
                    |m: &mut GetUsersRequest| { &mut m.usernames },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "facebook_ids",
                    |m: &GetUsersRequest| { &m.facebook_ids },
                    |m: &mut GetUsersRequest| { &mut m.facebook_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetUsersRequest>(
                    "GetUsersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetUsersRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetUsersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetUsersRequest,
        };
        unsafe {
            instance.get(GetUsersRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetUsersRequest {
    fn clear(&mut self) {
        self.clear_ids();
        self.clear_usernames();
        self.clear_facebook_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUsersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUsersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Group {
    // message fields
    pub id: ::std::string::String,
    pub creator_id: ::std::string::String,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub lang_tag: ::std::string::String,
    pub metadata: ::std::string::String,
    pub avatar_url: ::std::string::String,
    pub open: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub edge_count: i32,
    pub max_count: i32,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Group {
    pub fn new() -> Group {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string creator_id = 2;

    pub fn clear_creator_id(&mut self) {
        self.creator_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator_id(&mut self, v: ::std::string::String) {
        self.creator_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_id(&mut self) -> &mut ::std::string::String {
        &mut self.creator_id
    }

    // Take field
    pub fn take_creator_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator_id, ::std::string::String::new())
    }

    pub fn get_creator_id(&self) -> &str {
        &self.creator_id
    }

    // string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string description = 4;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string lang_tag = 5;

    pub fn clear_lang_tag(&mut self) {
        self.lang_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_lang_tag(&mut self, v: ::std::string::String) {
        self.lang_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang_tag(&mut self) -> &mut ::std::string::String {
        &mut self.lang_tag
    }

    // Take field
    pub fn take_lang_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lang_tag, ::std::string::String::new())
    }

    pub fn get_lang_tag(&self) -> &str {
        &self.lang_tag
    }

    // string metadata = 6;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }

    // string avatar_url = 7;

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        &mut self.avatar_url
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar_url, ::std::string::String::new())
    }

    pub fn get_avatar_url(&self) -> &str {
        &self.avatar_url
    }

    // .google.protobuf.BoolValue open = 8;

    pub fn clear_open(&mut self) {
        self.open.clear();
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.open = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_open(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.open.is_none() {
            self.open.set_default();
        }
        self.open.as_mut().unwrap()
    }

    // Take field
    pub fn take_open(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.open.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_open(&self) -> &::protobuf::well_known_types::BoolValue {
        self.open.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // int32 edge_count = 9;

    pub fn clear_edge_count(&mut self) {
        self.edge_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_count(&mut self, v: i32) {
        self.edge_count = v;
    }

    pub fn get_edge_count(&self) -> i32 {
        self.edge_count
    }

    // int32 max_count = 10;

    pub fn clear_max_count(&mut self) {
        self.max_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: i32) {
        self.max_count = v;
    }

    pub fn get_max_count(&self) -> i32 {
        self.max_count
    }

    // .google.protobuf.Timestamp create_time = 11;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 12;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for Group {
    fn is_initialized(&self) -> bool {
        for v in &self.open {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lang_tag)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.open)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edge_count = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_count = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.creator_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.creator_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if !self.lang_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.lang_tag);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.metadata);
        }
        if !self.avatar_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.avatar_url);
        }
        if let Some(ref v) = self.open.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.edge_count != 0 {
            my_size += ::protobuf::rt::value_size(9, self.edge_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_count != 0 {
            my_size += ::protobuf::rt::value_size(10, self.max_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.creator_id.is_empty() {
            os.write_string(2, &self.creator_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if !self.lang_tag.is_empty() {
            os.write_string(5, &self.lang_tag)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(6, &self.metadata)?;
        }
        if !self.avatar_url.is_empty() {
            os.write_string(7, &self.avatar_url)?;
        }
        if let Some(ref v) = self.open.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.edge_count != 0 {
            os.write_int32(9, self.edge_count)?;
        }
        if self.max_count != 0 {
            os.write_int32(10, self.max_count)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Group {
        Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Group| { &m.id },
                    |m: &mut Group| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "creator_id",
                    |m: &Group| { &m.creator_id },
                    |m: &mut Group| { &mut m.creator_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Group| { &m.name },
                    |m: &mut Group| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Group| { &m.description },
                    |m: &mut Group| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lang_tag",
                    |m: &Group| { &m.lang_tag },
                    |m: &mut Group| { &mut m.lang_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &Group| { &m.metadata },
                    |m: &mut Group| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "avatar_url",
                    |m: &Group| { &m.avatar_url },
                    |m: &mut Group| { &mut m.avatar_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "open",
                    |m: &Group| { &m.open },
                    |m: &mut Group| { &mut m.open },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_count",
                    |m: &Group| { &m.edge_count },
                    |m: &mut Group| { &mut m.edge_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_count",
                    |m: &Group| { &m.max_count },
                    |m: &mut Group| { &mut m.max_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &Group| { &m.create_time },
                    |m: &mut Group| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &Group| { &m.update_time },
                    |m: &mut Group| { &mut m.update_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Group>(
                    "Group",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Group {
        static mut instance: ::protobuf::lazy::Lazy<Group> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Group,
        };
        unsafe {
            instance.get(Group::new)
        }
    }
}

impl ::protobuf::Clear for Group {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_creator_id();
        self.clear_name();
        self.clear_description();
        self.clear_lang_tag();
        self.clear_metadata();
        self.clear_avatar_url();
        self.clear_open();
        self.clear_edge_count();
        self.clear_max_count();
        self.clear_create_time();
        self.clear_update_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupList {
    // message fields
    pub groups: ::protobuf::RepeatedField<Group>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupList {
    pub fn new() -> GroupList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Group groups = 1;

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<Group>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<Group> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<Group> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_groups(&self) -> &[Group] {
        &self.groups
    }

    // string cursor = 2;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for GroupList {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupList {
        GroupList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Group>>(
                    "groups",
                    |m: &GroupList| { &m.groups },
                    |m: &mut GroupList| { &mut m.groups },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &GroupList| { &m.cursor },
                    |m: &mut GroupList| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GroupList>(
                    "GroupList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GroupList {
        static mut instance: ::protobuf::lazy::Lazy<GroupList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupList,
        };
        unsafe {
            instance.get(GroupList::new)
        }
    }
}

impl ::protobuf::Clear for GroupList {
    fn clear(&mut self) {
        self.clear_groups();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupUserList {
    // message fields
    pub group_users: ::protobuf::RepeatedField<GroupUserList_GroupUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupUserList {
    pub fn new() -> GroupUserList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.GroupUserList.GroupUser group_users = 1;

    pub fn clear_group_users(&mut self) {
        self.group_users.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_users(&mut self, v: ::protobuf::RepeatedField<GroupUserList_GroupUser>) {
        self.group_users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group_users(&mut self) -> &mut ::protobuf::RepeatedField<GroupUserList_GroupUser> {
        &mut self.group_users
    }

    // Take field
    pub fn take_group_users(&mut self) -> ::protobuf::RepeatedField<GroupUserList_GroupUser> {
        ::std::mem::replace(&mut self.group_users, ::protobuf::RepeatedField::new())
    }

    pub fn get_group_users(&self) -> &[GroupUserList_GroupUser] {
        &self.group_users
    }
}

impl ::protobuf::Message for GroupUserList {
    fn is_initialized(&self) -> bool {
        for v in &self.group_users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.group_users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.group_users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.group_users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupUserList {
        GroupUserList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupUserList_GroupUser>>(
                    "group_users",
                    |m: &GroupUserList| { &m.group_users },
                    |m: &mut GroupUserList| { &mut m.group_users },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GroupUserList>(
                    "GroupUserList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GroupUserList {
        static mut instance: ::protobuf::lazy::Lazy<GroupUserList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupUserList,
        };
        unsafe {
            instance.get(GroupUserList::new)
        }
    }
}

impl ::protobuf::Clear for GroupUserList {
    fn clear(&mut self) {
        self.clear_group_users();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupUserList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupUserList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupUserList_GroupUser {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    pub state: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupUserList_GroupUser {
    pub fn new() -> GroupUserList_GroupUser {
        ::std::default::Default::default()
    }

    // .nakama.api.User user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| User::default_instance())
    }

    // .google.protobuf.Int32Value state = 2;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.state.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_state(&self) -> &::protobuf::well_known_types::Int32Value {
        self.state.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for GroupUserList_GroupUser {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupUserList_GroupUser {
        GroupUserList_GroupUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "user",
                    |m: &GroupUserList_GroupUser| { &m.user },
                    |m: &mut GroupUserList_GroupUser| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "state",
                    |m: &GroupUserList_GroupUser| { &m.state },
                    |m: &mut GroupUserList_GroupUser| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GroupUserList_GroupUser>(
                    "GroupUserList_GroupUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GroupUserList_GroupUser {
        static mut instance: ::protobuf::lazy::Lazy<GroupUserList_GroupUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupUserList_GroupUser,
        };
        unsafe {
            instance.get(GroupUserList_GroupUser::new)
        }
    }
}

impl ::protobuf::Clear for GroupUserList_GroupUser {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupUserList_GroupUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupUserList_GroupUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupUserList_GroupUser_State {
    SUPERADMIN = 0,
    ADMIN = 1,
    MEMBER = 2,
    JOIN_REQUEST = 3,
}

impl ::protobuf::ProtobufEnum for GroupUserList_GroupUser_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupUserList_GroupUser_State> {
        match value {
            0 => ::std::option::Option::Some(GroupUserList_GroupUser_State::SUPERADMIN),
            1 => ::std::option::Option::Some(GroupUserList_GroupUser_State::ADMIN),
            2 => ::std::option::Option::Some(GroupUserList_GroupUser_State::MEMBER),
            3 => ::std::option::Option::Some(GroupUserList_GroupUser_State::JOIN_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupUserList_GroupUser_State] = &[
            GroupUserList_GroupUser_State::SUPERADMIN,
            GroupUserList_GroupUser_State::ADMIN,
            GroupUserList_GroupUser_State::MEMBER,
            GroupUserList_GroupUser_State::JOIN_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GroupUserList_GroupUser_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GroupUserList_GroupUser_State {
}

impl ::std::default::Default for GroupUserList_GroupUser_State {
    fn default() -> Self {
        GroupUserList_GroupUser_State::SUPERADMIN
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupUserList_GroupUser_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportFacebookFriendsRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountFacebook>,
    pub reset: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImportFacebookFriendsRequest {
    pub fn new() -> ImportFacebookFriendsRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountFacebook account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountFacebook) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountFacebook {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountFacebook {
        self.account.take().unwrap_or_else(|| AccountFacebook::new())
    }

    pub fn get_account(&self) -> &AccountFacebook {
        self.account.as_ref().unwrap_or_else(|| AccountFacebook::default_instance())
    }

    // .google.protobuf.BoolValue reset = 2;

    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.reset.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_reset(&self) -> &::protobuf::well_known_types::BoolValue {
        self.reset.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for ImportFacebookFriendsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportFacebookFriendsRequest {
        ImportFacebookFriendsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountFacebook>>(
                    "account",
                    |m: &ImportFacebookFriendsRequest| { &m.account },
                    |m: &mut ImportFacebookFriendsRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "reset",
                    |m: &ImportFacebookFriendsRequest| { &m.reset },
                    |m: &mut ImportFacebookFriendsRequest| { &mut m.reset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImportFacebookFriendsRequest>(
                    "ImportFacebookFriendsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImportFacebookFriendsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ImportFacebookFriendsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImportFacebookFriendsRequest,
        };
        unsafe {
            instance.get(ImportFacebookFriendsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ImportFacebookFriendsRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_reset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportFacebookFriendsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportFacebookFriendsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JoinGroupRequest {
    // message fields
    pub group_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl JoinGroupRequest {
    pub fn new() -> JoinGroupRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }
}

impl ::protobuf::Message for JoinGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JoinGroupRequest {
        JoinGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &JoinGroupRequest| { &m.group_id },
                    |m: &mut JoinGroupRequest| { &mut m.group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JoinGroupRequest>(
                    "JoinGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JoinGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<JoinGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JoinGroupRequest,
        };
        unsafe {
            instance.get(JoinGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for JoinGroupRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JoinGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JoinTournamentRequest {
    // message fields
    pub tournament_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl JoinTournamentRequest {
    pub fn new() -> JoinTournamentRequest {
        ::std::default::Default::default()
    }

    // string tournament_id = 1;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: ::std::string::String) {
        self.tournament_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_id(&mut self) -> &mut ::std::string::String {
        &mut self.tournament_id
    }

    // Take field
    pub fn take_tournament_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tournament_id, ::std::string::String::new())
    }

    pub fn get_tournament_id(&self) -> &str {
        &self.tournament_id
    }
}

impl ::protobuf::Message for JoinTournamentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tournament_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tournament_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tournament_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tournament_id.is_empty() {
            os.write_string(1, &self.tournament_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JoinTournamentRequest {
        JoinTournamentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_id",
                    |m: &JoinTournamentRequest| { &m.tournament_id },
                    |m: &mut JoinTournamentRequest| { &mut m.tournament_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JoinTournamentRequest>(
                    "JoinTournamentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JoinTournamentRequest {
        static mut instance: ::protobuf::lazy::Lazy<JoinTournamentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JoinTournamentRequest,
        };
        unsafe {
            instance.get(JoinTournamentRequest::new)
        }
    }
}

impl ::protobuf::Clear for JoinTournamentRequest {
    fn clear(&mut self) {
        self.clear_tournament_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JoinTournamentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinTournamentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KickGroupUsersRequest {
    // message fields
    pub group_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KickGroupUsersRequest {
    pub fn new() -> KickGroupUsersRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }

    // repeated string user_ids = 2;

    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
}

impl ::protobuf::Message for KickGroupUsersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KickGroupUsersRequest {
        KickGroupUsersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &KickGroupUsersRequest| { &m.group_id },
                    |m: &mut KickGroupUsersRequest| { &mut m.group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_ids",
                    |m: &KickGroupUsersRequest| { &m.user_ids },
                    |m: &mut KickGroupUsersRequest| { &mut m.user_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KickGroupUsersRequest>(
                    "KickGroupUsersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KickGroupUsersRequest {
        static mut instance: ::protobuf::lazy::Lazy<KickGroupUsersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KickGroupUsersRequest,
        };
        unsafe {
            instance.get(KickGroupUsersRequest::new)
        }
    }
}

impl ::protobuf::Clear for KickGroupUsersRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.clear_user_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KickGroupUsersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KickGroupUsersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaderboardRecord {
    // message fields
    pub leaderboard_id: ::std::string::String,
    pub owner_id: ::std::string::String,
    pub username: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub score: i64,
    pub subscore: i64,
    pub num_score: i32,
    pub metadata: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub expiry_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub rank: i64,
    pub max_num_score: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LeaderboardRecord {
    pub fn new() -> LeaderboardRecord {
        ::std::default::Default::default()
    }

    // string leaderboard_id = 1;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: ::std::string::String) {
        self.leaderboard_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_id(&mut self) -> &mut ::std::string::String {
        &mut self.leaderboard_id
    }

    // Take field
    pub fn take_leaderboard_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaderboard_id, ::std::string::String::new())
    }

    pub fn get_leaderboard_id(&self) -> &str {
        &self.leaderboard_id
    }

    // string owner_id = 2;

    pub fn clear_owner_id(&mut self) {
        self.owner_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: ::std::string::String) {
        self.owner_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_id(&mut self) -> &mut ::std::string::String {
        &mut self.owner_id
    }

    // Take field
    pub fn take_owner_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner_id, ::std::string::String::new())
    }

    pub fn get_owner_id(&self) -> &str {
        &self.owner_id
    }

    // .google.protobuf.StringValue username = 3;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.username = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.username.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_username(&self) -> &::protobuf::well_known_types::StringValue {
        self.username.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // int64 score = 4;

    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i64) {
        self.score = v;
    }

    pub fn get_score(&self) -> i64 {
        self.score
    }

    // int64 subscore = 5;

    pub fn clear_subscore(&mut self) {
        self.subscore = 0;
    }

    // Param is passed by value, moved
    pub fn set_subscore(&mut self, v: i64) {
        self.subscore = v;
    }

    pub fn get_subscore(&self) -> i64 {
        self.subscore
    }

    // int32 num_score = 6;

    pub fn clear_num_score(&mut self) {
        self.num_score = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_score(&mut self, v: i32) {
        self.num_score = v;
    }

    pub fn get_num_score(&self) -> i32 {
        self.num_score
    }

    // string metadata = 7;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }

    // .google.protobuf.Timestamp create_time = 8;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 9;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp expiry_time = 10;

    pub fn clear_expiry_time(&mut self) {
        self.expiry_time.clear();
    }

    pub fn has_expiry_time(&self) -> bool {
        self.expiry_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expiry_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiry_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expiry_time.is_none() {
            self.expiry_time.set_default();
        }
        self.expiry_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiry_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expiry_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_expiry_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expiry_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // int64 rank = 11;

    pub fn clear_rank(&mut self) {
        self.rank = 0;
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: i64) {
        self.rank = v;
    }

    pub fn get_rank(&self) -> i64 {
        self.rank
    }

    // uint32 max_num_score = 12;

    pub fn clear_max_num_score(&mut self) {
        self.max_num_score = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_num_score(&mut self, v: u32) {
        self.max_num_score = v;
    }

    pub fn get_max_num_score(&self) -> u32 {
        self.max_num_score
    }
}

impl ::protobuf::Message for LeaderboardRecord {
    fn is_initialized(&self) -> bool {
        for v in &self.username {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiry_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.leaderboard_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.username)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.score = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.subscore = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_score = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiry_time)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rank = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_num_score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.leaderboard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.leaderboard_id);
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.owner_id);
        }
        if let Some(ref v) = self.username.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(4, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.subscore != 0 {
            my_size += ::protobuf::rt::value_size(5, self.subscore, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_score != 0 {
            my_size += ::protobuf::rt::value_size(6, self.num_score, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.metadata);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expiry_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.rank != 0 {
            my_size += ::protobuf::rt::value_size(11, self.rank, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_num_score != 0 {
            my_size += ::protobuf::rt::value_size(12, self.max_num_score, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.leaderboard_id.is_empty() {
            os.write_string(1, &self.leaderboard_id)?;
        }
        if !self.owner_id.is_empty() {
            os.write_string(2, &self.owner_id)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.score != 0 {
            os.write_int64(4, self.score)?;
        }
        if self.subscore != 0 {
            os.write_int64(5, self.subscore)?;
        }
        if self.num_score != 0 {
            os.write_int32(6, self.num_score)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(7, &self.metadata)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expiry_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.rank != 0 {
            os.write_int64(11, self.rank)?;
        }
        if self.max_num_score != 0 {
            os.write_uint32(12, self.max_num_score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaderboardRecord {
        LeaderboardRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "leaderboard_id",
                    |m: &LeaderboardRecord| { &m.leaderboard_id },
                    |m: &mut LeaderboardRecord| { &mut m.leaderboard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_id",
                    |m: &LeaderboardRecord| { &m.owner_id },
                    |m: &mut LeaderboardRecord| { &mut m.owner_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "username",
                    |m: &LeaderboardRecord| { &m.username },
                    |m: &mut LeaderboardRecord| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "score",
                    |m: &LeaderboardRecord| { &m.score },
                    |m: &mut LeaderboardRecord| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "subscore",
                    |m: &LeaderboardRecord| { &m.subscore },
                    |m: &mut LeaderboardRecord| { &mut m.subscore },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_score",
                    |m: &LeaderboardRecord| { &m.num_score },
                    |m: &mut LeaderboardRecord| { &mut m.num_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &LeaderboardRecord| { &m.metadata },
                    |m: &mut LeaderboardRecord| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &LeaderboardRecord| { &m.create_time },
                    |m: &mut LeaderboardRecord| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &LeaderboardRecord| { &m.update_time },
                    |m: &mut LeaderboardRecord| { &mut m.update_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "expiry_time",
                    |m: &LeaderboardRecord| { &m.expiry_time },
                    |m: &mut LeaderboardRecord| { &mut m.expiry_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "rank",
                    |m: &LeaderboardRecord| { &m.rank },
                    |m: &mut LeaderboardRecord| { &mut m.rank },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_num_score",
                    |m: &LeaderboardRecord| { &m.max_num_score },
                    |m: &mut LeaderboardRecord| { &mut m.max_num_score },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaderboardRecord>(
                    "LeaderboardRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaderboardRecord {
        static mut instance: ::protobuf::lazy::Lazy<LeaderboardRecord> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaderboardRecord,
        };
        unsafe {
            instance.get(LeaderboardRecord::new)
        }
    }
}

impl ::protobuf::Clear for LeaderboardRecord {
    fn clear(&mut self) {
        self.clear_leaderboard_id();
        self.clear_owner_id();
        self.clear_username();
        self.clear_score();
        self.clear_subscore();
        self.clear_num_score();
        self.clear_metadata();
        self.clear_create_time();
        self.clear_update_time();
        self.clear_expiry_time();
        self.clear_rank();
        self.clear_max_num_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaderboardRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaderboardRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaderboardRecordList {
    // message fields
    pub records: ::protobuf::RepeatedField<LeaderboardRecord>,
    pub owner_records: ::protobuf::RepeatedField<LeaderboardRecord>,
    pub next_cursor: ::std::string::String,
    pub prev_cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LeaderboardRecordList {
    pub fn new() -> LeaderboardRecordList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.LeaderboardRecord records = 1;

    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<LeaderboardRecord>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<LeaderboardRecord> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<LeaderboardRecord> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }

    pub fn get_records(&self) -> &[LeaderboardRecord] {
        &self.records
    }

    // repeated .nakama.api.LeaderboardRecord owner_records = 2;

    pub fn clear_owner_records(&mut self) {
        self.owner_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_records(&mut self, v: ::protobuf::RepeatedField<LeaderboardRecord>) {
        self.owner_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owner_records(&mut self) -> &mut ::protobuf::RepeatedField<LeaderboardRecord> {
        &mut self.owner_records
    }

    // Take field
    pub fn take_owner_records(&mut self) -> ::protobuf::RepeatedField<LeaderboardRecord> {
        ::std::mem::replace(&mut self.owner_records, ::protobuf::RepeatedField::new())
    }

    pub fn get_owner_records(&self) -> &[LeaderboardRecord] {
        &self.owner_records
    }

    // string next_cursor = 3;

    pub fn clear_next_cursor(&mut self) {
        self.next_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_cursor(&mut self, v: ::std::string::String) {
        self.next_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.next_cursor
    }

    // Take field
    pub fn take_next_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_cursor, ::std::string::String::new())
    }

    pub fn get_next_cursor(&self) -> &str {
        &self.next_cursor
    }

    // string prev_cursor = 4;

    pub fn clear_prev_cursor(&mut self) {
        self.prev_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_cursor(&mut self, v: ::std::string::String) {
        self.prev_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.prev_cursor
    }

    // Take field
    pub fn take_prev_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prev_cursor, ::std::string::String::new())
    }

    pub fn get_prev_cursor(&self) -> &str {
        &self.prev_cursor
    }
}

impl ::protobuf::Message for LeaderboardRecordList {
    fn is_initialized(&self) -> bool {
        for v in &self.records {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.records)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owner_records)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_cursor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prev_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.owner_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_cursor);
        }
        if !self.prev_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.prev_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.owner_records {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_cursor.is_empty() {
            os.write_string(3, &self.next_cursor)?;
        }
        if !self.prev_cursor.is_empty() {
            os.write_string(4, &self.prev_cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaderboardRecordList {
        LeaderboardRecordList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeaderboardRecord>>(
                    "records",
                    |m: &LeaderboardRecordList| { &m.records },
                    |m: &mut LeaderboardRecordList| { &mut m.records },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeaderboardRecord>>(
                    "owner_records",
                    |m: &LeaderboardRecordList| { &m.owner_records },
                    |m: &mut LeaderboardRecordList| { &mut m.owner_records },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_cursor",
                    |m: &LeaderboardRecordList| { &m.next_cursor },
                    |m: &mut LeaderboardRecordList| { &mut m.next_cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prev_cursor",
                    |m: &LeaderboardRecordList| { &m.prev_cursor },
                    |m: &mut LeaderboardRecordList| { &mut m.prev_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaderboardRecordList>(
                    "LeaderboardRecordList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaderboardRecordList {
        static mut instance: ::protobuf::lazy::Lazy<LeaderboardRecordList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaderboardRecordList,
        };
        unsafe {
            instance.get(LeaderboardRecordList::new)
        }
    }
}

impl ::protobuf::Clear for LeaderboardRecordList {
    fn clear(&mut self) {
        self.clear_records();
        self.clear_owner_records();
        self.clear_next_cursor();
        self.clear_prev_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaderboardRecordList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaderboardRecordList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaveGroupRequest {
    // message fields
    pub group_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LeaveGroupRequest {
    pub fn new() -> LeaveGroupRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }
}

impl ::protobuf::Message for LeaveGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaveGroupRequest {
        LeaveGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &LeaveGroupRequest| { &m.group_id },
                    |m: &mut LeaveGroupRequest| { &mut m.group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LeaveGroupRequest>(
                    "LeaveGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LeaveGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<LeaveGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaveGroupRequest,
        };
        unsafe {
            instance.get(LeaveGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for LeaveGroupRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaveGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaveGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkFacebookRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountFacebook>,
    pub sync: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LinkFacebookRequest {
    pub fn new() -> LinkFacebookRequest {
        ::std::default::Default::default()
    }

    // .nakama.api.AccountFacebook account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountFacebook) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountFacebook {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountFacebook {
        self.account.take().unwrap_or_else(|| AccountFacebook::new())
    }

    pub fn get_account(&self) -> &AccountFacebook {
        self.account.as_ref().unwrap_or_else(|| AccountFacebook::default_instance())
    }

    // .google.protobuf.BoolValue sync = 4;

    pub fn clear_sync(&mut self) {
        self.sync.clear();
    }

    pub fn has_sync(&self) -> bool {
        self.sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.sync = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sync(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.sync.is_none() {
            self.sync.set_default();
        }
        self.sync.as_mut().unwrap()
    }

    // Take field
    pub fn take_sync(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.sync.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_sync(&self) -> &::protobuf::well_known_types::BoolValue {
        self.sync.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for LinkFacebookRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sync {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sync)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sync.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sync.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkFacebookRequest {
        LinkFacebookRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountFacebook>>(
                    "account",
                    |m: &LinkFacebookRequest| { &m.account },
                    |m: &mut LinkFacebookRequest| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "sync",
                    |m: &LinkFacebookRequest| { &m.sync },
                    |m: &mut LinkFacebookRequest| { &mut m.sync },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LinkFacebookRequest>(
                    "LinkFacebookRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinkFacebookRequest {
        static mut instance: ::protobuf::lazy::Lazy<LinkFacebookRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LinkFacebookRequest,
        };
        unsafe {
            instance.get(LinkFacebookRequest::new)
        }
    }
}

impl ::protobuf::Clear for LinkFacebookRequest {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_sync();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkFacebookRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkFacebookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelMessagesRequest {
    // message fields
    pub channel_id: ::std::string::String,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub forward: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListChannelMessagesRequest {
    pub fn new() -> ListChannelMessagesRequest {
        ::std::default::Default::default()
    }

    // string channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }

    // .google.protobuf.Int32Value limit = 2;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.BoolValue forward = 3;

    pub fn clear_forward(&mut self) {
        self.forward.clear();
    }

    pub fn has_forward(&self) -> bool {
        self.forward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.forward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.forward.is_none() {
            self.forward.set_default();
        }
        self.forward.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.forward.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_forward(&self) -> &::protobuf::well_known_types::BoolValue {
        self.forward.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // string cursor = 4;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for ListChannelMessagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.forward {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forward)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.forward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.forward.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(4, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelMessagesRequest {
        ListChannelMessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_id",
                    |m: &ListChannelMessagesRequest| { &m.channel_id },
                    |m: &mut ListChannelMessagesRequest| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListChannelMessagesRequest| { &m.limit },
                    |m: &mut ListChannelMessagesRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "forward",
                    |m: &ListChannelMessagesRequest| { &m.forward },
                    |m: &mut ListChannelMessagesRequest| { &mut m.forward },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListChannelMessagesRequest| { &m.cursor },
                    |m: &mut ListChannelMessagesRequest| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChannelMessagesRequest>(
                    "ListChannelMessagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChannelMessagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListChannelMessagesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChannelMessagesRequest,
        };
        unsafe {
            instance.get(ListChannelMessagesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListChannelMessagesRequest {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_limit();
        self.clear_forward();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelMessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupsRequest {
    // message fields
    pub name: ::std::string::String,
    pub cursor: ::std::string::String,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListGroupsRequest {
    pub fn new() -> ListGroupsRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string cursor = 2;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }

    // .google.protobuf.Int32Value limit = 3;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for ListGroupsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupsRequest {
        ListGroupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListGroupsRequest| { &m.name },
                    |m: &mut ListGroupsRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListGroupsRequest| { &m.cursor },
                    |m: &mut ListGroupsRequest| { &mut m.cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListGroupsRequest| { &m.limit },
                    |m: &mut ListGroupsRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListGroupsRequest>(
                    "ListGroupsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListGroupsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListGroupsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListGroupsRequest,
        };
        unsafe {
            instance.get(ListGroupsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListGroupsRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_cursor();
        self.clear_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupUsersRequest {
    // message fields
    pub group_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListGroupUsersRequest {
    pub fn new() -> ListGroupUsersRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }
}

impl ::protobuf::Message for ListGroupUsersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupUsersRequest {
        ListGroupUsersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &ListGroupUsersRequest| { &m.group_id },
                    |m: &mut ListGroupUsersRequest| { &mut m.group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListGroupUsersRequest>(
                    "ListGroupUsersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListGroupUsersRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListGroupUsersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListGroupUsersRequest,
        };
        unsafe {
            instance.get(ListGroupUsersRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListGroupUsersRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupUsersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupUsersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLeaderboardRecordsAroundOwnerRequest {
    // message fields
    pub leaderboard_id: ::std::string::String,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub owner_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListLeaderboardRecordsAroundOwnerRequest {
    pub fn new() -> ListLeaderboardRecordsAroundOwnerRequest {
        ::std::default::Default::default()
    }

    // string leaderboard_id = 1;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: ::std::string::String) {
        self.leaderboard_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_id(&mut self) -> &mut ::std::string::String {
        &mut self.leaderboard_id
    }

    // Take field
    pub fn take_leaderboard_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaderboard_id, ::std::string::String::new())
    }

    pub fn get_leaderboard_id(&self) -> &str {
        &self.leaderboard_id
    }

    // .google.protobuf.UInt32Value limit = 2;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // string owner_id = 3;

    pub fn clear_owner_id(&mut self) {
        self.owner_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: ::std::string::String) {
        self.owner_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_id(&mut self) -> &mut ::std::string::String {
        &mut self.owner_id
    }

    // Take field
    pub fn take_owner_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner_id, ::std::string::String::new())
    }

    pub fn get_owner_id(&self) -> &str {
        &self.owner_id
    }
}

impl ::protobuf::Message for ListLeaderboardRecordsAroundOwnerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.leaderboard_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.leaderboard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.leaderboard_id);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.leaderboard_id.is_empty() {
            os.write_string(1, &self.leaderboard_id)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner_id.is_empty() {
            os.write_string(3, &self.owner_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLeaderboardRecordsAroundOwnerRequest {
        ListLeaderboardRecordsAroundOwnerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "leaderboard_id",
                    |m: &ListLeaderboardRecordsAroundOwnerRequest| { &m.leaderboard_id },
                    |m: &mut ListLeaderboardRecordsAroundOwnerRequest| { &mut m.leaderboard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "limit",
                    |m: &ListLeaderboardRecordsAroundOwnerRequest| { &m.limit },
                    |m: &mut ListLeaderboardRecordsAroundOwnerRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_id",
                    |m: &ListLeaderboardRecordsAroundOwnerRequest| { &m.owner_id },
                    |m: &mut ListLeaderboardRecordsAroundOwnerRequest| { &mut m.owner_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLeaderboardRecordsAroundOwnerRequest>(
                    "ListLeaderboardRecordsAroundOwnerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLeaderboardRecordsAroundOwnerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListLeaderboardRecordsAroundOwnerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLeaderboardRecordsAroundOwnerRequest,
        };
        unsafe {
            instance.get(ListLeaderboardRecordsAroundOwnerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListLeaderboardRecordsAroundOwnerRequest {
    fn clear(&mut self) {
        self.clear_leaderboard_id();
        self.clear_limit();
        self.clear_owner_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLeaderboardRecordsAroundOwnerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLeaderboardRecordsAroundOwnerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLeaderboardRecordsRequest {
    // message fields
    pub leaderboard_id: ::std::string::String,
    pub owner_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListLeaderboardRecordsRequest {
    pub fn new() -> ListLeaderboardRecordsRequest {
        ::std::default::Default::default()
    }

    // string leaderboard_id = 1;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: ::std::string::String) {
        self.leaderboard_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_id(&mut self) -> &mut ::std::string::String {
        &mut self.leaderboard_id
    }

    // Take field
    pub fn take_leaderboard_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaderboard_id, ::std::string::String::new())
    }

    pub fn get_leaderboard_id(&self) -> &str {
        &self.leaderboard_id
    }

    // repeated string owner_ids = 2;

    pub fn clear_owner_ids(&mut self) {
        self.owner_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.owner_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owner_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.owner_ids
    }

    // Take field
    pub fn take_owner_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.owner_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_owner_ids(&self) -> &[::std::string::String] {
        &self.owner_ids
    }

    // .google.protobuf.Int32Value limit = 3;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string cursor = 4;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for ListLeaderboardRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.leaderboard_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.owner_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.leaderboard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.leaderboard_id);
        }
        for value in &self.owner_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.leaderboard_id.is_empty() {
            os.write_string(1, &self.leaderboard_id)?;
        }
        for v in &self.owner_ids {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(4, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLeaderboardRecordsRequest {
        ListLeaderboardRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "leaderboard_id",
                    |m: &ListLeaderboardRecordsRequest| { &m.leaderboard_id },
                    |m: &mut ListLeaderboardRecordsRequest| { &mut m.leaderboard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_ids",
                    |m: &ListLeaderboardRecordsRequest| { &m.owner_ids },
                    |m: &mut ListLeaderboardRecordsRequest| { &mut m.owner_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListLeaderboardRecordsRequest| { &m.limit },
                    |m: &mut ListLeaderboardRecordsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListLeaderboardRecordsRequest| { &m.cursor },
                    |m: &mut ListLeaderboardRecordsRequest| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLeaderboardRecordsRequest>(
                    "ListLeaderboardRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLeaderboardRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListLeaderboardRecordsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLeaderboardRecordsRequest,
        };
        unsafe {
            instance.get(ListLeaderboardRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListLeaderboardRecordsRequest {
    fn clear(&mut self) {
        self.clear_leaderboard_id();
        self.clear_owner_ids();
        self.clear_limit();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLeaderboardRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLeaderboardRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMatchesRequest {
    // message fields
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub authoritative: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub label: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub min_size: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub max_size: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub query: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListMatchesRequest {
    pub fn new() -> ListMatchesRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int32Value limit = 1;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.BoolValue authoritative = 2;

    pub fn clear_authoritative(&mut self) {
        self.authoritative.clear();
    }

    pub fn has_authoritative(&self) -> bool {
        self.authoritative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.authoritative = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authoritative(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.authoritative.is_none() {
            self.authoritative.set_default();
        }
        self.authoritative.as_mut().unwrap()
    }

    // Take field
    pub fn take_authoritative(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.authoritative.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_authoritative(&self) -> &::protobuf::well_known_types::BoolValue {
        self.authoritative.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }

    // .google.protobuf.StringValue label = 3;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.label.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_label(&self) -> &::protobuf::well_known_types::StringValue {
        self.label.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.Int32Value min_size = 4;

    pub fn clear_min_size(&mut self) {
        self.min_size.clear();
    }

    pub fn has_min_size(&self) -> bool {
        self.min_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_size(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.min_size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_size(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.min_size.is_none() {
            self.min_size.set_default();
        }
        self.min_size.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_size(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.min_size.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_min_size(&self) -> &::protobuf::well_known_types::Int32Value {
        self.min_size.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.Int32Value max_size = 5;

    pub fn clear_max_size(&mut self) {
        self.max_size.clear();
    }

    pub fn has_max_size(&self) -> bool {
        self.max_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_size(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.max_size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_size(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.max_size.is_none() {
            self.max_size.set_default();
        }
        self.max_size.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_size(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.max_size.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_max_size(&self) -> &::protobuf::well_known_types::Int32Value {
        self.max_size.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.StringValue query = 6;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.query.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_query(&self) -> &::protobuf::well_known_types::StringValue {
        self.query.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }
}

impl ::protobuf::Message for ListMatchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authoritative {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authoritative)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_size)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_size)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authoritative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.min_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authoritative.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.min_size.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_size.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMatchesRequest {
        ListMatchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListMatchesRequest| { &m.limit },
                    |m: &mut ListMatchesRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "authoritative",
                    |m: &ListMatchesRequest| { &m.authoritative },
                    |m: &mut ListMatchesRequest| { &mut m.authoritative },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "label",
                    |m: &ListMatchesRequest| { &m.label },
                    |m: &mut ListMatchesRequest| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "min_size",
                    |m: &ListMatchesRequest| { &m.min_size },
                    |m: &mut ListMatchesRequest| { &mut m.min_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "max_size",
                    |m: &ListMatchesRequest| { &m.max_size },
                    |m: &mut ListMatchesRequest| { &mut m.max_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "query",
                    |m: &ListMatchesRequest| { &m.query },
                    |m: &mut ListMatchesRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListMatchesRequest>(
                    "ListMatchesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListMatchesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListMatchesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListMatchesRequest,
        };
        unsafe {
            instance.get(ListMatchesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListMatchesRequest {
    fn clear(&mut self) {
        self.clear_limit();
        self.clear_authoritative();
        self.clear_label();
        self.clear_min_size();
        self.clear_max_size();
        self.clear_query();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMatchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMatchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNotificationsRequest {
    // message fields
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub cacheable_cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListNotificationsRequest {
    pub fn new() -> ListNotificationsRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int32Value limit = 1;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string cacheable_cursor = 2;

    pub fn clear_cacheable_cursor(&mut self) {
        self.cacheable_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cacheable_cursor(&mut self, v: ::std::string::String) {
        self.cacheable_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cacheable_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cacheable_cursor
    }

    // Take field
    pub fn take_cacheable_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cacheable_cursor, ::std::string::String::new())
    }

    pub fn get_cacheable_cursor(&self) -> &str {
        &self.cacheable_cursor
    }
}

impl ::protobuf::Message for ListNotificationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cacheable_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cacheable_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cacheable_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cacheable_cursor.is_empty() {
            os.write_string(2, &self.cacheable_cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNotificationsRequest {
        ListNotificationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListNotificationsRequest| { &m.limit },
                    |m: &mut ListNotificationsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cacheable_cursor",
                    |m: &ListNotificationsRequest| { &m.cacheable_cursor },
                    |m: &mut ListNotificationsRequest| { &mut m.cacheable_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListNotificationsRequest>(
                    "ListNotificationsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListNotificationsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListNotificationsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListNotificationsRequest,
        };
        unsafe {
            instance.get(ListNotificationsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListNotificationsRequest {
    fn clear(&mut self) {
        self.clear_limit();
        self.clear_cacheable_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNotificationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNotificationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStorageObjectsRequest {
    // message fields
    pub user_id: ::std::string::String,
    pub collection: ::std::string::String,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListStorageObjectsRequest {
    pub fn new() -> ListStorageObjectsRequest {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // string collection = 2;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // .google.protobuf.Int32Value limit = 3;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string cursor = 4;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for ListStorageObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.collection.is_empty() {
            os.write_string(2, &self.collection)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(4, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStorageObjectsRequest {
        ListStorageObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &ListStorageObjectsRequest| { &m.user_id },
                    |m: &mut ListStorageObjectsRequest| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &ListStorageObjectsRequest| { &m.collection },
                    |m: &mut ListStorageObjectsRequest| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListStorageObjectsRequest| { &m.limit },
                    |m: &mut ListStorageObjectsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListStorageObjectsRequest| { &m.cursor },
                    |m: &mut ListStorageObjectsRequest| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListStorageObjectsRequest>(
                    "ListStorageObjectsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListStorageObjectsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListStorageObjectsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListStorageObjectsRequest,
        };
        unsafe {
            instance.get(ListStorageObjectsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListStorageObjectsRequest {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_collection();
        self.clear_limit();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStorageObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStorageObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTournamentRecordsAroundOwnerRequest {
    // message fields
    pub tournament_id: ::std::string::String,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub owner_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListTournamentRecordsAroundOwnerRequest {
    pub fn new() -> ListTournamentRecordsAroundOwnerRequest {
        ::std::default::Default::default()
    }

    // string tournament_id = 1;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: ::std::string::String) {
        self.tournament_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_id(&mut self) -> &mut ::std::string::String {
        &mut self.tournament_id
    }

    // Take field
    pub fn take_tournament_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tournament_id, ::std::string::String::new())
    }

    pub fn get_tournament_id(&self) -> &str {
        &self.tournament_id
    }

    // .google.protobuf.UInt32Value limit = 2;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // string owner_id = 3;

    pub fn clear_owner_id(&mut self) {
        self.owner_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: ::std::string::String) {
        self.owner_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_id(&mut self) -> &mut ::std::string::String {
        &mut self.owner_id
    }

    // Take field
    pub fn take_owner_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner_id, ::std::string::String::new())
    }

    pub fn get_owner_id(&self) -> &str {
        &self.owner_id
    }
}

impl ::protobuf::Message for ListTournamentRecordsAroundOwnerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tournament_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tournament_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tournament_id);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tournament_id.is_empty() {
            os.write_string(1, &self.tournament_id)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner_id.is_empty() {
            os.write_string(3, &self.owner_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTournamentRecordsAroundOwnerRequest {
        ListTournamentRecordsAroundOwnerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_id",
                    |m: &ListTournamentRecordsAroundOwnerRequest| { &m.tournament_id },
                    |m: &mut ListTournamentRecordsAroundOwnerRequest| { &mut m.tournament_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "limit",
                    |m: &ListTournamentRecordsAroundOwnerRequest| { &m.limit },
                    |m: &mut ListTournamentRecordsAroundOwnerRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_id",
                    |m: &ListTournamentRecordsAroundOwnerRequest| { &m.owner_id },
                    |m: &mut ListTournamentRecordsAroundOwnerRequest| { &mut m.owner_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTournamentRecordsAroundOwnerRequest>(
                    "ListTournamentRecordsAroundOwnerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTournamentRecordsAroundOwnerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTournamentRecordsAroundOwnerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTournamentRecordsAroundOwnerRequest,
        };
        unsafe {
            instance.get(ListTournamentRecordsAroundOwnerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTournamentRecordsAroundOwnerRequest {
    fn clear(&mut self) {
        self.clear_tournament_id();
        self.clear_limit();
        self.clear_owner_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTournamentRecordsAroundOwnerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTournamentRecordsAroundOwnerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTournamentRecordsRequest {
    // message fields
    pub tournament_id: ::std::string::String,
    pub owner_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListTournamentRecordsRequest {
    pub fn new() -> ListTournamentRecordsRequest {
        ::std::default::Default::default()
    }

    // string tournament_id = 1;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: ::std::string::String) {
        self.tournament_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_id(&mut self) -> &mut ::std::string::String {
        &mut self.tournament_id
    }

    // Take field
    pub fn take_tournament_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tournament_id, ::std::string::String::new())
    }

    pub fn get_tournament_id(&self) -> &str {
        &self.tournament_id
    }

    // repeated string owner_ids = 2;

    pub fn clear_owner_ids(&mut self) {
        self.owner_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.owner_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owner_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.owner_ids
    }

    // Take field
    pub fn take_owner_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.owner_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_owner_ids(&self) -> &[::std::string::String] {
        &self.owner_ids
    }

    // .google.protobuf.Int32Value limit = 3;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string cursor = 4;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for ListTournamentRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tournament_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.owner_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tournament_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tournament_id);
        }
        for value in &self.owner_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tournament_id.is_empty() {
            os.write_string(1, &self.tournament_id)?;
        }
        for v in &self.owner_ids {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(4, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTournamentRecordsRequest {
        ListTournamentRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_id",
                    |m: &ListTournamentRecordsRequest| { &m.tournament_id },
                    |m: &mut ListTournamentRecordsRequest| { &mut m.tournament_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_ids",
                    |m: &ListTournamentRecordsRequest| { &m.owner_ids },
                    |m: &mut ListTournamentRecordsRequest| { &mut m.owner_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListTournamentRecordsRequest| { &m.limit },
                    |m: &mut ListTournamentRecordsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListTournamentRecordsRequest| { &m.cursor },
                    |m: &mut ListTournamentRecordsRequest| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTournamentRecordsRequest>(
                    "ListTournamentRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTournamentRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTournamentRecordsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTournamentRecordsRequest,
        };
        unsafe {
            instance.get(ListTournamentRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTournamentRecordsRequest {
    fn clear(&mut self) {
        self.clear_tournament_id();
        self.clear_owner_ids();
        self.clear_limit();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTournamentRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTournamentRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTournamentsRequest {
    // message fields
    pub category_start: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub category_end: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListTournamentsRequest {
    pub fn new() -> ListTournamentsRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value category_start = 1;

    pub fn clear_category_start(&mut self) {
        self.category_start.clear();
    }

    pub fn has_category_start(&self) -> bool {
        self.category_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_start(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.category_start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_start(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.category_start.is_none() {
            self.category_start.set_default();
        }
        self.category_start.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_start(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.category_start.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_category_start(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.category_start.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // .google.protobuf.UInt32Value category_end = 2;

    pub fn clear_category_end(&mut self) {
        self.category_end.clear();
    }

    pub fn has_category_end(&self) -> bool {
        self.category_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_end(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.category_end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_end(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.category_end.is_none() {
            self.category_end.set_default();
        }
        self.category_end.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_end(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.category_end.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_category_end(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.category_end.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // .google.protobuf.UInt32Value start_time = 3;

    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_start_time(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.start_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // .google.protobuf.UInt32Value end_time = 4;

    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    pub fn get_end_time(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.end_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::default_instance())
    }

    // .google.protobuf.Int32Value limit = 6;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // string cursor = 8;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for ListTournamentsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.category_start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.category_end {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.category_start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.category_end)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.category_start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.category_end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.category_start.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.category_end.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cursor.is_empty() {
            os.write_string(8, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTournamentsRequest {
        ListTournamentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "category_start",
                    |m: &ListTournamentsRequest| { &m.category_start },
                    |m: &mut ListTournamentsRequest| { &mut m.category_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "category_end",
                    |m: &ListTournamentsRequest| { &m.category_end },
                    |m: &mut ListTournamentsRequest| { &mut m.category_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "start_time",
                    |m: &ListTournamentsRequest| { &m.start_time },
                    |m: &mut ListTournamentsRequest| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                    "end_time",
                    |m: &ListTournamentsRequest| { &m.end_time },
                    |m: &mut ListTournamentsRequest| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &ListTournamentsRequest| { &m.limit },
                    |m: &mut ListTournamentsRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &ListTournamentsRequest| { &m.cursor },
                    |m: &mut ListTournamentsRequest| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTournamentsRequest>(
                    "ListTournamentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTournamentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTournamentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTournamentsRequest,
        };
        unsafe {
            instance.get(ListTournamentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTournamentsRequest {
    fn clear(&mut self) {
        self.clear_category_start();
        self.clear_category_end();
        self.clear_start_time();
        self.clear_end_time();
        self.clear_limit();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTournamentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTournamentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUserGroupsRequest {
    // message fields
    pub user_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListUserGroupsRequest {
    pub fn new() -> ListUserGroupsRequest {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
}

impl ::protobuf::Message for ListUserGroupsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUserGroupsRequest {
        ListUserGroupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &ListUserGroupsRequest| { &m.user_id },
                    |m: &mut ListUserGroupsRequest| { &mut m.user_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListUserGroupsRequest>(
                    "ListUserGroupsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListUserGroupsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListUserGroupsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListUserGroupsRequest,
        };
        unsafe {
            instance.get(ListUserGroupsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListUserGroupsRequest {
    fn clear(&mut self) {
        self.clear_user_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUserGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUserGroupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Match {
    // message fields
    pub match_id: ::std::string::String,
    pub authoritative: bool,
    pub label: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Match {
    pub fn new() -> Match {
        ::std::default::Default::default()
    }

    // string match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: ::std::string::String) {
        self.match_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_id(&mut self) -> &mut ::std::string::String {
        &mut self.match_id
    }

    // Take field
    pub fn take_match_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.match_id, ::std::string::String::new())
    }

    pub fn get_match_id(&self) -> &str {
        &self.match_id
    }

    // bool authoritative = 2;

    pub fn clear_authoritative(&mut self) {
        self.authoritative = false;
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = v;
    }

    pub fn get_authoritative(&self) -> bool {
        self.authoritative
    }

    // .google.protobuf.StringValue label = 3;

    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.label.is_none() {
            self.label.set_default();
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.label.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_label(&self) -> &::protobuf::well_known_types::StringValue {
        self.label.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // int32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = v;
    }

    pub fn get_size(&self) -> i32 {
        self.size
    }
}

impl ::protobuf::Message for Match {
    fn is_initialized(&self) -> bool {
        for v in &self.label {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.match_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.match_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.match_id);
        }
        if self.authoritative != false {
            my_size += 2;
        }
        if let Some(ref v) = self.label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.match_id.is_empty() {
            os.write_string(1, &self.match_id)?;
        }
        if self.authoritative != false {
            os.write_bool(2, self.authoritative)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size != 0 {
            os.write_int32(4, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Match {
        Match::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_id",
                    |m: &Match| { &m.match_id },
                    |m: &mut Match| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "authoritative",
                    |m: &Match| { &m.authoritative },
                    |m: &mut Match| { &mut m.authoritative },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "label",
                    |m: &Match| { &m.label },
                    |m: &mut Match| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size",
                    |m: &Match| { &m.size },
                    |m: &mut Match| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Match>(
                    "Match",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Match {
        static mut instance: ::protobuf::lazy::Lazy<Match> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Match,
        };
        unsafe {
            instance.get(Match::new)
        }
    }
}

impl ::protobuf::Clear for Match {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_authoritative();
        self.clear_label();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Match {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchList {
    // message fields
    pub matches: ::protobuf::RepeatedField<Match>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchList {
    pub fn new() -> MatchList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Match matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<Match>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<Match> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<Match> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[Match] {
        &self.matches
    }
}

impl ::protobuf::Message for MatchList {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchList {
        MatchList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Match>>(
                    "matches",
                    |m: &MatchList| { &m.matches },
                    |m: &mut MatchList| { &mut m.matches },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchList>(
                    "MatchList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchList {
        static mut instance: ::protobuf::lazy::Lazy<MatchList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchList,
        };
        unsafe {
            instance.get(MatchList::new)
        }
    }
}

impl ::protobuf::Clear for MatchList {
    fn clear(&mut self) {
        self.clear_matches();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Notification {
    // message fields
    pub id: ::std::string::String,
    pub subject: ::std::string::String,
    pub content: ::std::string::String,
    pub code: i32,
    pub sender_id: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub persistent: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string subject = 2;

    pub fn clear_subject(&mut self) {
        self.subject.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        &mut self.subject
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subject, ::std::string::String::new())
    }

    pub fn get_subject(&self) -> &str {
        &self.subject
    }

    // string content = 3;

    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    pub fn get_content(&self) -> &str {
        &self.content
    }

    // int32 code = 4;

    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    pub fn get_code(&self) -> i32 {
        self.code
    }

    // string sender_id = 5;

    pub fn clear_sender_id(&mut self) {
        self.sender_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: ::std::string::String) {
        self.sender_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_id(&mut self) -> &mut ::std::string::String {
        &mut self.sender_id
    }

    // Take field
    pub fn take_sender_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender_id, ::std::string::String::new())
    }

    pub fn get_sender_id(&self) -> &str {
        &self.sender_id
    }

    // .google.protobuf.Timestamp create_time = 6;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // bool persistent = 7;

    pub fn clear_persistent(&mut self) {
        self.persistent = false;
    }

    // Param is passed by value, moved
    pub fn set_persistent(&mut self, v: bool) {
        self.persistent = v;
    }

    pub fn get_persistent(&self) -> bool {
        self.persistent
    }
}

impl ::protobuf::Message for Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subject)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persistent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subject);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.content);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(4, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sender_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sender_id);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.persistent != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.subject.is_empty() {
            os.write_string(2, &self.subject)?;
        }
        if !self.content.is_empty() {
            os.write_string(3, &self.content)?;
        }
        if self.code != 0 {
            os.write_int32(4, self.code)?;
        }
        if !self.sender_id.is_empty() {
            os.write_string(5, &self.sender_id)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.persistent != false {
            os.write_bool(7, self.persistent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Notification| { &m.id },
                    |m: &mut Notification| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subject",
                    |m: &Notification| { &m.subject },
                    |m: &mut Notification| { &mut m.subject },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &Notification| { &m.content },
                    |m: &mut Notification| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &Notification| { &m.code },
                    |m: &mut Notification| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sender_id",
                    |m: &Notification| { &m.sender_id },
                    |m: &mut Notification| { &mut m.sender_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &Notification| { &m.create_time },
                    |m: &mut Notification| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "persistent",
                    |m: &Notification| { &m.persistent },
                    |m: &mut Notification| { &mut m.persistent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Notification>(
                    "Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Notification {
        static mut instance: ::protobuf::lazy::Lazy<Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Notification,
        };
        unsafe {
            instance.get(Notification::new)
        }
    }
}

impl ::protobuf::Clear for Notification {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_subject();
        self.clear_content();
        self.clear_code();
        self.clear_sender_id();
        self.clear_create_time();
        self.clear_persistent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NotificationList {
    // message fields
    pub notifications: ::protobuf::RepeatedField<Notification>,
    pub cacheable_cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NotificationList {
    pub fn new() -> NotificationList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Notification notifications = 1;

    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<Notification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<Notification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<Notification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }

    pub fn get_notifications(&self) -> &[Notification] {
        &self.notifications
    }

    // string cacheable_cursor = 2;

    pub fn clear_cacheable_cursor(&mut self) {
        self.cacheable_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cacheable_cursor(&mut self, v: ::std::string::String) {
        self.cacheable_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cacheable_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cacheable_cursor
    }

    // Take field
    pub fn take_cacheable_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cacheable_cursor, ::std::string::String::new())
    }

    pub fn get_cacheable_cursor(&self) -> &str {
        &self.cacheable_cursor
    }
}

impl ::protobuf::Message for NotificationList {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cacheable_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cacheable_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cacheable_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notifications {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cacheable_cursor.is_empty() {
            os.write_string(2, &self.cacheable_cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NotificationList {
        NotificationList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Notification>>(
                    "notifications",
                    |m: &NotificationList| { &m.notifications },
                    |m: &mut NotificationList| { &mut m.notifications },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cacheable_cursor",
                    |m: &NotificationList| { &m.cacheable_cursor },
                    |m: &mut NotificationList| { &mut m.cacheable_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NotificationList>(
                    "NotificationList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NotificationList {
        static mut instance: ::protobuf::lazy::Lazy<NotificationList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NotificationList,
        };
        unsafe {
            instance.get(NotificationList::new)
        }
    }
}

impl ::protobuf::Clear for NotificationList {
    fn clear(&mut self) {
        self.clear_notifications();
        self.clear_cacheable_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NotificationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotificationList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PromoteGroupUsersRequest {
    // message fields
    pub group_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PromoteGroupUsersRequest {
    pub fn new() -> PromoteGroupUsersRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }

    // repeated string user_ids = 2;

    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
}

impl ::protobuf::Message for PromoteGroupUsersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PromoteGroupUsersRequest {
        PromoteGroupUsersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &PromoteGroupUsersRequest| { &m.group_id },
                    |m: &mut PromoteGroupUsersRequest| { &mut m.group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_ids",
                    |m: &PromoteGroupUsersRequest| { &m.user_ids },
                    |m: &mut PromoteGroupUsersRequest| { &mut m.user_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PromoteGroupUsersRequest>(
                    "PromoteGroupUsersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PromoteGroupUsersRequest {
        static mut instance: ::protobuf::lazy::Lazy<PromoteGroupUsersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PromoteGroupUsersRequest,
        };
        unsafe {
            instance.get(PromoteGroupUsersRequest::new)
        }
    }
}

impl ::protobuf::Clear for PromoteGroupUsersRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.clear_user_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PromoteGroupUsersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromoteGroupUsersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStorageObjectId {
    // message fields
    pub collection: ::std::string::String,
    pub key: ::std::string::String,
    pub user_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReadStorageObjectId {
    pub fn new() -> ReadStorageObjectId {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        &self.key
    }

    // string user_id = 3;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
}

impl ::protobuf::Message for ReadStorageObjectId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(3, &self.user_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStorageObjectId {
        ReadStorageObjectId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &ReadStorageObjectId| { &m.collection },
                    |m: &mut ReadStorageObjectId| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &ReadStorageObjectId| { &m.key },
                    |m: &mut ReadStorageObjectId| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &ReadStorageObjectId| { &m.user_id },
                    |m: &mut ReadStorageObjectId| { &mut m.user_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStorageObjectId>(
                    "ReadStorageObjectId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStorageObjectId {
        static mut instance: ::protobuf::lazy::Lazy<ReadStorageObjectId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStorageObjectId,
        };
        unsafe {
            instance.get(ReadStorageObjectId::new)
        }
    }
}

impl ::protobuf::Clear for ReadStorageObjectId {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_key();
        self.clear_user_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStorageObjectId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStorageObjectId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadStorageObjectsRequest {
    // message fields
    pub object_ids: ::protobuf::RepeatedField<ReadStorageObjectId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReadStorageObjectsRequest {
    pub fn new() -> ReadStorageObjectsRequest {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.ReadStorageObjectId object_ids = 1;

    pub fn clear_object_ids(&mut self) {
        self.object_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_ids(&mut self, v: ::protobuf::RepeatedField<ReadStorageObjectId>) {
        self.object_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_ids(&mut self) -> &mut ::protobuf::RepeatedField<ReadStorageObjectId> {
        &mut self.object_ids
    }

    // Take field
    pub fn take_object_ids(&mut self) -> ::protobuf::RepeatedField<ReadStorageObjectId> {
        ::std::mem::replace(&mut self.object_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_object_ids(&self) -> &[ReadStorageObjectId] {
        &self.object_ids
    }
}

impl ::protobuf::Message for ReadStorageObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.object_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.object_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.object_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadStorageObjectsRequest {
        ReadStorageObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadStorageObjectId>>(
                    "object_ids",
                    |m: &ReadStorageObjectsRequest| { &m.object_ids },
                    |m: &mut ReadStorageObjectsRequest| { &mut m.object_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadStorageObjectsRequest>(
                    "ReadStorageObjectsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadStorageObjectsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadStorageObjectsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadStorageObjectsRequest,
        };
        unsafe {
            instance.get(ReadStorageObjectsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadStorageObjectsRequest {
    fn clear(&mut self) {
        self.clear_object_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadStorageObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadStorageObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rpc {
    // message fields
    pub id: ::std::string::String,
    pub payload: ::std::string::String,
    pub http_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Rpc {
    pub fn new() -> Rpc {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string payload = 2;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::string::String) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::string::String {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload, ::std::string::String::new())
    }

    pub fn get_payload(&self) -> &str {
        &self.payload
    }

    // string http_key = 3;

    pub fn clear_http_key(&mut self) {
        self.http_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_http_key(&mut self, v: ::std::string::String) {
        self.http_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_key(&mut self) -> &mut ::std::string::String {
        &mut self.http_key
    }

    // Take field
    pub fn take_http_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.http_key, ::std::string::String::new())
    }

    pub fn get_http_key(&self) -> &str {
        &self.http_key
    }
}

impl ::protobuf::Message for Rpc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.http_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payload);
        }
        if !self.http_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.http_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.payload.is_empty() {
            os.write_string(2, &self.payload)?;
        }
        if !self.http_key.is_empty() {
            os.write_string(3, &self.http_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rpc {
        Rpc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Rpc| { &m.id },
                    |m: &mut Rpc| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload",
                    |m: &Rpc| { &m.payload },
                    |m: &mut Rpc| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "http_key",
                    |m: &Rpc| { &m.http_key },
                    |m: &mut Rpc| { &mut m.http_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rpc>(
                    "Rpc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rpc {
        static mut instance: ::protobuf::lazy::Lazy<Rpc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rpc,
        };
        unsafe {
            instance.get(Rpc::new)
        }
    }
}

impl ::protobuf::Clear for Rpc {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_payload();
        self.clear_http_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rpc {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Session {
    // message fields
    pub created: bool,
    pub token: ::std::string::String,
    pub udp_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Session {
    pub fn new() -> Session {
        ::std::default::Default::default()
    }

    // bool created = 1;

    pub fn clear_created(&mut self) {
        self.created = false;
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: bool) {
        self.created = v;
    }

    pub fn get_created(&self) -> bool {
        self.created
    }

    // string token = 2;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    pub fn get_token(&self) -> &str {
        &self.token
    }

    // string udp_token = 3;

    pub fn clear_udp_token(&mut self) {
        self.udp_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_udp_token(&mut self, v: ::std::string::String) {
        self.udp_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_udp_token(&mut self) -> &mut ::std::string::String {
        &mut self.udp_token
    }

    // Take field
    pub fn take_udp_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.udp_token, ::std::string::String::new())
    }

    pub fn get_udp_token(&self) -> &str {
        &self.udp_token
    }
}

impl ::protobuf::Message for Session {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.created = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.udp_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.created != false {
            my_size += 2;
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.token);
        }
        if !self.udp_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.udp_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.created != false {
            os.write_bool(1, self.created)?;
        }
        if !self.token.is_empty() {
            os.write_string(2, &self.token)?;
        }
        if !self.udp_token.is_empty() {
            os.write_string(3, &self.udp_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Session {
        Session::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "created",
                    |m: &Session| { &m.created },
                    |m: &mut Session| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &Session| { &m.token },
                    |m: &mut Session| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "udp_token",
                    |m: &Session| { &m.udp_token },
                    |m: &mut Session| { &mut m.udp_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Session>(
                    "Session",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Session {
        static mut instance: ::protobuf::lazy::Lazy<Session> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Session,
        };
        unsafe {
            instance.get(Session::new)
        }
    }
}

impl ::protobuf::Clear for Session {
    fn clear(&mut self) {
        self.clear_created();
        self.clear_token();
        self.clear_udp_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Session {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Session {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageObject {
    // message fields
    pub collection: ::std::string::String,
    pub key: ::std::string::String,
    pub user_id: ::std::string::String,
    pub value: ::std::string::String,
    pub version: ::std::string::String,
    pub permission_read: i32,
    pub permission_write: i32,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StorageObject {
    pub fn new() -> StorageObject {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        &self.key
    }

    // string user_id = 3;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // string value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // string version = 5;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // int32 permission_read = 6;

    pub fn clear_permission_read(&mut self) {
        self.permission_read = 0;
    }

    // Param is passed by value, moved
    pub fn set_permission_read(&mut self, v: i32) {
        self.permission_read = v;
    }

    pub fn get_permission_read(&self) -> i32 {
        self.permission_read
    }

    // int32 permission_write = 7;

    pub fn clear_permission_write(&mut self) {
        self.permission_write = 0;
    }

    // Param is passed by value, moved
    pub fn set_permission_write(&mut self, v: i32) {
        self.permission_write = v;
    }

    pub fn get_permission_write(&self) -> i32 {
        self.permission_write
    }

    // .google.protobuf.Timestamp create_time = 8;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 9;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for StorageObject {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission_read = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permission_write = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_id);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.version);
        }
        if self.permission_read != 0 {
            my_size += ::protobuf::rt::value_size(6, self.permission_read, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.permission_write != 0 {
            my_size += ::protobuf::rt::value_size(7, self.permission_write, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(3, &self.user_id)?;
        }
        if !self.value.is_empty() {
            os.write_string(4, &self.value)?;
        }
        if !self.version.is_empty() {
            os.write_string(5, &self.version)?;
        }
        if self.permission_read != 0 {
            os.write_int32(6, self.permission_read)?;
        }
        if self.permission_write != 0 {
            os.write_int32(7, self.permission_write)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageObject {
        StorageObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &StorageObject| { &m.collection },
                    |m: &mut StorageObject| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StorageObject| { &m.key },
                    |m: &mut StorageObject| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &StorageObject| { &m.user_id },
                    |m: &mut StorageObject| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &StorageObject| { &m.value },
                    |m: &mut StorageObject| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &StorageObject| { &m.version },
                    |m: &mut StorageObject| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "permission_read",
                    |m: &StorageObject| { &m.permission_read },
                    |m: &mut StorageObject| { &mut m.permission_read },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "permission_write",
                    |m: &StorageObject| { &m.permission_write },
                    |m: &mut StorageObject| { &mut m.permission_write },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &StorageObject| { &m.create_time },
                    |m: &mut StorageObject| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &StorageObject| { &m.update_time },
                    |m: &mut StorageObject| { &mut m.update_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageObject>(
                    "StorageObject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageObject {
        static mut instance: ::protobuf::lazy::Lazy<StorageObject> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageObject,
        };
        unsafe {
            instance.get(StorageObject::new)
        }
    }
}

impl ::protobuf::Clear for StorageObject {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_key();
        self.clear_user_id();
        self.clear_value();
        self.clear_version();
        self.clear_permission_read();
        self.clear_permission_write();
        self.clear_create_time();
        self.clear_update_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageObject {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageObjectAck {
    // message fields
    pub collection: ::std::string::String,
    pub key: ::std::string::String,
    pub version: ::std::string::String,
    pub user_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StorageObjectAck {
    pub fn new() -> StorageObjectAck {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        &self.key
    }

    // string version = 3;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // string user_id = 4;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
}

impl ::protobuf::Message for StorageObjectAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageObjectAck {
        StorageObjectAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &StorageObjectAck| { &m.collection },
                    |m: &mut StorageObjectAck| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StorageObjectAck| { &m.key },
                    |m: &mut StorageObjectAck| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &StorageObjectAck| { &m.version },
                    |m: &mut StorageObjectAck| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &StorageObjectAck| { &m.user_id },
                    |m: &mut StorageObjectAck| { &mut m.user_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageObjectAck>(
                    "StorageObjectAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageObjectAck {
        static mut instance: ::protobuf::lazy::Lazy<StorageObjectAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageObjectAck,
        };
        unsafe {
            instance.get(StorageObjectAck::new)
        }
    }
}

impl ::protobuf::Clear for StorageObjectAck {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_key();
        self.clear_version();
        self.clear_user_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageObjectAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageObjectAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageObjectAcks {
    // message fields
    pub acks: ::protobuf::RepeatedField<StorageObjectAck>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StorageObjectAcks {
    pub fn new() -> StorageObjectAcks {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.StorageObjectAck acks = 1;

    pub fn clear_acks(&mut self) {
        self.acks.clear();
    }

    // Param is passed by value, moved
    pub fn set_acks(&mut self, v: ::protobuf::RepeatedField<StorageObjectAck>) {
        self.acks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acks(&mut self) -> &mut ::protobuf::RepeatedField<StorageObjectAck> {
        &mut self.acks
    }

    // Take field
    pub fn take_acks(&mut self) -> ::protobuf::RepeatedField<StorageObjectAck> {
        ::std::mem::replace(&mut self.acks, ::protobuf::RepeatedField::new())
    }

    pub fn get_acks(&self) -> &[StorageObjectAck] {
        &self.acks
    }
}

impl ::protobuf::Message for StorageObjectAcks {
    fn is_initialized(&self) -> bool {
        for v in &self.acks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.acks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.acks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageObjectAcks {
        StorageObjectAcks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageObjectAck>>(
                    "acks",
                    |m: &StorageObjectAcks| { &m.acks },
                    |m: &mut StorageObjectAcks| { &mut m.acks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageObjectAcks>(
                    "StorageObjectAcks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageObjectAcks {
        static mut instance: ::protobuf::lazy::Lazy<StorageObjectAcks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageObjectAcks,
        };
        unsafe {
            instance.get(StorageObjectAcks::new)
        }
    }
}

impl ::protobuf::Clear for StorageObjectAcks {
    fn clear(&mut self) {
        self.clear_acks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageObjectAcks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageObjectAcks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageObjects {
    // message fields
    pub objects: ::protobuf::RepeatedField<StorageObject>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StorageObjects {
    pub fn new() -> StorageObjects {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.StorageObject objects = 1;

    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<StorageObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<StorageObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<StorageObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }

    pub fn get_objects(&self) -> &[StorageObject] {
        &self.objects
    }
}

impl ::protobuf::Message for StorageObjects {
    fn is_initialized(&self) -> bool {
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.objects {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageObjects {
        StorageObjects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageObject>>(
                    "objects",
                    |m: &StorageObjects| { &m.objects },
                    |m: &mut StorageObjects| { &mut m.objects },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageObjects>(
                    "StorageObjects",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageObjects {
        static mut instance: ::protobuf::lazy::Lazy<StorageObjects> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageObjects,
        };
        unsafe {
            instance.get(StorageObjects::new)
        }
    }
}

impl ::protobuf::Clear for StorageObjects {
    fn clear(&mut self) {
        self.clear_objects();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageObjects {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageObjectList {
    // message fields
    pub objects: ::protobuf::RepeatedField<StorageObject>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StorageObjectList {
    pub fn new() -> StorageObjectList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.StorageObject objects = 1;

    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<StorageObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<StorageObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<StorageObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }

    pub fn get_objects(&self) -> &[StorageObject] {
        &self.objects
    }

    // string cursor = 2;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for StorageObjectList {
    fn is_initialized(&self) -> bool {
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.objects {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageObjectList {
        StorageObjectList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageObject>>(
                    "objects",
                    |m: &StorageObjectList| { &m.objects },
                    |m: &mut StorageObjectList| { &mut m.objects },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &StorageObjectList| { &m.cursor },
                    |m: &mut StorageObjectList| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageObjectList>(
                    "StorageObjectList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageObjectList {
        static mut instance: ::protobuf::lazy::Lazy<StorageObjectList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageObjectList,
        };
        unsafe {
            instance.get(StorageObjectList::new)
        }
    }
}

impl ::protobuf::Clear for StorageObjectList {
    fn clear(&mut self) {
        self.clear_objects();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageObjectList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageObjectList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tournament {
    // message fields
    pub id: ::std::string::String,
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub category: u32,
    pub sort_order: u32,
    pub size: u32,
    pub max_size: u32,
    pub max_num_score: u32,
    pub can_enter: bool,
    pub end_active: u32,
    pub next_reset: u32,
    pub metadata: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub duration: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Tournament {
    pub fn new() -> Tournament {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string title = 2;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        &self.title
    }

    // string description = 3;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // uint32 category = 4;

    pub fn clear_category(&mut self) {
        self.category = 0;
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = v;
    }

    pub fn get_category(&self) -> u32 {
        self.category
    }

    // uint32 sort_order = 5;

    pub fn clear_sort_order(&mut self) {
        self.sort_order = 0;
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = v;
    }

    pub fn get_sort_order(&self) -> u32 {
        self.sort_order
    }

    // uint32 size = 6;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    pub fn get_size(&self) -> u32 {
        self.size
    }

    // uint32 max_size = 7;

    pub fn clear_max_size(&mut self) {
        self.max_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_size(&mut self, v: u32) {
        self.max_size = v;
    }

    pub fn get_max_size(&self) -> u32 {
        self.max_size
    }

    // uint32 max_num_score = 8;

    pub fn clear_max_num_score(&mut self) {
        self.max_num_score = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_num_score(&mut self, v: u32) {
        self.max_num_score = v;
    }

    pub fn get_max_num_score(&self) -> u32 {
        self.max_num_score
    }

    // bool can_enter = 9;

    pub fn clear_can_enter(&mut self) {
        self.can_enter = false;
    }

    // Param is passed by value, moved
    pub fn set_can_enter(&mut self, v: bool) {
        self.can_enter = v;
    }

    pub fn get_can_enter(&self) -> bool {
        self.can_enter
    }

    // uint32 end_active = 10;

    pub fn clear_end_active(&mut self) {
        self.end_active = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_active(&mut self, v: u32) {
        self.end_active = v;
    }

    pub fn get_end_active(&self) -> u32 {
        self.end_active
    }

    // uint32 next_reset = 11;

    pub fn clear_next_reset(&mut self) {
        self.next_reset = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_reset(&mut self, v: u32) {
        self.next_reset = v;
    }

    pub fn get_next_reset(&self) -> u32 {
        self.next_reset
    }

    // string metadata = 12;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }

    // .google.protobuf.Timestamp create_time = 13;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp start_time = 14;

    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp end_time = 15;

    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // uint32 duration = 16;

    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = v;
    }

    pub fn get_duration(&self) -> u32 {
        self.duration
    }
}

impl ::protobuf::Message for Tournament {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.category = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_order = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_num_score = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_enter = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_active = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.next_reset = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.category != 0 {
            my_size += ::protobuf::rt::value_size(4, self.category, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_order != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sort_order, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.max_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_num_score != 0 {
            my_size += ::protobuf::rt::value_size(8, self.max_num_score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.can_enter != false {
            my_size += 2;
        }
        if self.end_active != 0 {
            my_size += ::protobuf::rt::value_size(10, self.end_active, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_reset != 0 {
            my_size += ::protobuf::rt::value_size(11, self.next_reset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.metadata);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(16, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.category != 0 {
            os.write_uint32(4, self.category)?;
        }
        if self.sort_order != 0 {
            os.write_uint32(5, self.sort_order)?;
        }
        if self.size != 0 {
            os.write_uint32(6, self.size)?;
        }
        if self.max_size != 0 {
            os.write_uint32(7, self.max_size)?;
        }
        if self.max_num_score != 0 {
            os.write_uint32(8, self.max_num_score)?;
        }
        if self.can_enter != false {
            os.write_bool(9, self.can_enter)?;
        }
        if self.end_active != 0 {
            os.write_uint32(10, self.end_active)?;
        }
        if self.next_reset != 0 {
            os.write_uint32(11, self.next_reset)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(12, &self.metadata)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.duration != 0 {
            os.write_uint32(16, self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tournament {
        Tournament::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Tournament| { &m.id },
                    |m: &mut Tournament| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &Tournament| { &m.title },
                    |m: &mut Tournament| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Tournament| { &m.description },
                    |m: &mut Tournament| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "category",
                    |m: &Tournament| { &m.category },
                    |m: &mut Tournament| { &mut m.category },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sort_order",
                    |m: &Tournament| { &m.sort_order },
                    |m: &mut Tournament| { &mut m.sort_order },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &Tournament| { &m.size },
                    |m: &mut Tournament| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_size",
                    |m: &Tournament| { &m.max_size },
                    |m: &mut Tournament| { &mut m.max_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_num_score",
                    |m: &Tournament| { &m.max_num_score },
                    |m: &mut Tournament| { &mut m.max_num_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_enter",
                    |m: &Tournament| { &m.can_enter },
                    |m: &mut Tournament| { &mut m.can_enter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_active",
                    |m: &Tournament| { &m.end_active },
                    |m: &mut Tournament| { &mut m.end_active },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "next_reset",
                    |m: &Tournament| { &m.next_reset },
                    |m: &mut Tournament| { &mut m.next_reset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &Tournament| { &m.metadata },
                    |m: &mut Tournament| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &Tournament| { &m.create_time },
                    |m: &mut Tournament| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "start_time",
                    |m: &Tournament| { &m.start_time },
                    |m: &mut Tournament| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "end_time",
                    |m: &Tournament| { &m.end_time },
                    |m: &mut Tournament| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration",
                    |m: &Tournament| { &m.duration },
                    |m: &mut Tournament| { &mut m.duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tournament>(
                    "Tournament",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Tournament {
        static mut instance: ::protobuf::lazy::Lazy<Tournament> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Tournament,
        };
        unsafe {
            instance.get(Tournament::new)
        }
    }
}

impl ::protobuf::Clear for Tournament {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_title();
        self.clear_description();
        self.clear_category();
        self.clear_sort_order();
        self.clear_size();
        self.clear_max_size();
        self.clear_max_num_score();
        self.clear_can_enter();
        self.clear_end_active();
        self.clear_next_reset();
        self.clear_metadata();
        self.clear_create_time();
        self.clear_start_time();
        self.clear_end_time();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tournament {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tournament {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentList {
    // message fields
    pub tournaments: ::protobuf::RepeatedField<Tournament>,
    pub cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TournamentList {
    pub fn new() -> TournamentList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.Tournament tournaments = 1;

    pub fn clear_tournaments(&mut self) {
        self.tournaments.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournaments(&mut self, v: ::protobuf::RepeatedField<Tournament>) {
        self.tournaments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournaments(&mut self) -> &mut ::protobuf::RepeatedField<Tournament> {
        &mut self.tournaments
    }

    // Take field
    pub fn take_tournaments(&mut self) -> ::protobuf::RepeatedField<Tournament> {
        ::std::mem::replace(&mut self.tournaments, ::protobuf::RepeatedField::new())
    }

    pub fn get_tournaments(&self) -> &[Tournament] {
        &self.tournaments
    }

    // string cursor = 2;

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.cursor
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cursor, ::std::string::String::new())
    }

    pub fn get_cursor(&self) -> &str {
        &self.cursor
    }
}

impl ::protobuf::Message for TournamentList {
    fn is_initialized(&self) -> bool {
        for v in &self.tournaments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tournaments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tournaments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tournaments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cursor.is_empty() {
            os.write_string(2, &self.cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentList {
        TournamentList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tournament>>(
                    "tournaments",
                    |m: &TournamentList| { &m.tournaments },
                    |m: &mut TournamentList| { &mut m.tournaments },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &TournamentList| { &m.cursor },
                    |m: &mut TournamentList| { &mut m.cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentList>(
                    "TournamentList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentList {
        static mut instance: ::protobuf::lazy::Lazy<TournamentList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentList,
        };
        unsafe {
            instance.get(TournamentList::new)
        }
    }
}

impl ::protobuf::Clear for TournamentList {
    fn clear(&mut self) {
        self.clear_tournaments();
        self.clear_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentRecordList {
    // message fields
    pub records: ::protobuf::RepeatedField<LeaderboardRecord>,
    pub owner_records: ::protobuf::RepeatedField<LeaderboardRecord>,
    pub next_cursor: ::std::string::String,
    pub prev_cursor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TournamentRecordList {
    pub fn new() -> TournamentRecordList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.LeaderboardRecord records = 1;

    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<LeaderboardRecord>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<LeaderboardRecord> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<LeaderboardRecord> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }

    pub fn get_records(&self) -> &[LeaderboardRecord] {
        &self.records
    }

    // repeated .nakama.api.LeaderboardRecord owner_records = 2;

    pub fn clear_owner_records(&mut self) {
        self.owner_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_records(&mut self, v: ::protobuf::RepeatedField<LeaderboardRecord>) {
        self.owner_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owner_records(&mut self) -> &mut ::protobuf::RepeatedField<LeaderboardRecord> {
        &mut self.owner_records
    }

    // Take field
    pub fn take_owner_records(&mut self) -> ::protobuf::RepeatedField<LeaderboardRecord> {
        ::std::mem::replace(&mut self.owner_records, ::protobuf::RepeatedField::new())
    }

    pub fn get_owner_records(&self) -> &[LeaderboardRecord] {
        &self.owner_records
    }

    // string next_cursor = 3;

    pub fn clear_next_cursor(&mut self) {
        self.next_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_cursor(&mut self, v: ::std::string::String) {
        self.next_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.next_cursor
    }

    // Take field
    pub fn take_next_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_cursor, ::std::string::String::new())
    }

    pub fn get_next_cursor(&self) -> &str {
        &self.next_cursor
    }

    // string prev_cursor = 4;

    pub fn clear_prev_cursor(&mut self) {
        self.prev_cursor.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_cursor(&mut self, v: ::std::string::String) {
        self.prev_cursor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_cursor(&mut self) -> &mut ::std::string::String {
        &mut self.prev_cursor
    }

    // Take field
    pub fn take_prev_cursor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prev_cursor, ::std::string::String::new())
    }

    pub fn get_prev_cursor(&self) -> &str {
        &self.prev_cursor
    }
}

impl ::protobuf::Message for TournamentRecordList {
    fn is_initialized(&self) -> bool {
        for v in &self.records {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.records)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owner_records)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_cursor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prev_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.owner_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_cursor);
        }
        if !self.prev_cursor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.prev_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.owner_records {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_cursor.is_empty() {
            os.write_string(3, &self.next_cursor)?;
        }
        if !self.prev_cursor.is_empty() {
            os.write_string(4, &self.prev_cursor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentRecordList {
        TournamentRecordList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeaderboardRecord>>(
                    "records",
                    |m: &TournamentRecordList| { &m.records },
                    |m: &mut TournamentRecordList| { &mut m.records },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LeaderboardRecord>>(
                    "owner_records",
                    |m: &TournamentRecordList| { &m.owner_records },
                    |m: &mut TournamentRecordList| { &mut m.owner_records },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_cursor",
                    |m: &TournamentRecordList| { &m.next_cursor },
                    |m: &mut TournamentRecordList| { &mut m.next_cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prev_cursor",
                    |m: &TournamentRecordList| { &m.prev_cursor },
                    |m: &mut TournamentRecordList| { &mut m.prev_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentRecordList>(
                    "TournamentRecordList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentRecordList {
        static mut instance: ::protobuf::lazy::Lazy<TournamentRecordList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentRecordList,
        };
        unsafe {
            instance.get(TournamentRecordList::new)
        }
    }
}

impl ::protobuf::Clear for TournamentRecordList {
    fn clear(&mut self) {
        self.clear_records();
        self.clear_owner_records();
        self.clear_next_cursor();
        self.clear_prev_cursor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentRecordList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentRecordList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAccountRequest {
    // message fields
    pub username: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub display_name: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub avatar_url: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub lang_tag: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub location: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub timezone: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateAccountRequest {
    pub fn new() -> UpdateAccountRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.StringValue username = 1;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.username = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.username.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_username(&self) -> &::protobuf::well_known_types::StringValue {
        self.username.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue display_name = 2;

    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.display_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.display_name.is_none() {
            self.display_name.set_default();
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.display_name.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_display_name(&self) -> &::protobuf::well_known_types::StringValue {
        self.display_name.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue avatar_url = 3;

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.avatar_url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.avatar_url.is_none() {
            self.avatar_url.set_default();
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.avatar_url.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_avatar_url(&self) -> &::protobuf::well_known_types::StringValue {
        self.avatar_url.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue lang_tag = 4;

    pub fn clear_lang_tag(&mut self) {
        self.lang_tag.clear();
    }

    pub fn has_lang_tag(&self) -> bool {
        self.lang_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lang_tag(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.lang_tag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang_tag(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.lang_tag.is_none() {
            self.lang_tag.set_default();
        }
        self.lang_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_lang_tag(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.lang_tag.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_lang_tag(&self) -> &::protobuf::well_known_types::StringValue {
        self.lang_tag.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue location = 5;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.location.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_location(&self) -> &::protobuf::well_known_types::StringValue {
        self.location.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue timezone = 6;

    pub fn clear_timezone(&mut self) {
        self.timezone.clear();
    }

    pub fn has_timezone(&self) -> bool {
        self.timezone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.timezone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timezone(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.timezone.is_none() {
            self.timezone.set_default();
        }
        self.timezone.as_mut().unwrap()
    }

    // Take field
    pub fn take_timezone(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.timezone.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_timezone(&self) -> &::protobuf::well_known_types::StringValue {
        self.timezone.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }
}

impl ::protobuf::Message for UpdateAccountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.username {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar_url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lang_tag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timezone {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lang_tag)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timezone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.username.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lang_tag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timezone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.username.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.display_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lang_tag.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timezone.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAccountRequest {
        UpdateAccountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "username",
                    |m: &UpdateAccountRequest| { &m.username },
                    |m: &mut UpdateAccountRequest| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "display_name",
                    |m: &UpdateAccountRequest| { &m.display_name },
                    |m: &mut UpdateAccountRequest| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "avatar_url",
                    |m: &UpdateAccountRequest| { &m.avatar_url },
                    |m: &mut UpdateAccountRequest| { &mut m.avatar_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "lang_tag",
                    |m: &UpdateAccountRequest| { &m.lang_tag },
                    |m: &mut UpdateAccountRequest| { &mut m.lang_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "location",
                    |m: &UpdateAccountRequest| { &m.location },
                    |m: &mut UpdateAccountRequest| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "timezone",
                    |m: &UpdateAccountRequest| { &m.timezone },
                    |m: &mut UpdateAccountRequest| { &mut m.timezone },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateAccountRequest>(
                    "UpdateAccountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateAccountRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateAccountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateAccountRequest,
        };
        unsafe {
            instance.get(UpdateAccountRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateAccountRequest {
    fn clear(&mut self) {
        self.clear_username();
        self.clear_display_name();
        self.clear_avatar_url();
        self.clear_lang_tag();
        self.clear_location();
        self.clear_timezone();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAccountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAccountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateGroupRequest {
    // message fields
    pub group_id: ::std::string::String,
    pub name: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub description: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub lang_tag: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub avatar_url: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub open: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateGroupRequest {
    pub fn new() -> UpdateGroupRequest {
        ::std::default::Default::default()
    }

    // string group_id = 1;

    pub fn clear_group_id(&mut self) {
        self.group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ::std::string::String) {
        self.group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.group_id
    }

    // Take field
    pub fn take_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group_id, ::std::string::String::new())
    }

    pub fn get_group_id(&self) -> &str {
        &self.group_id
    }

    // .google.protobuf.StringValue name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.name.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_name(&self) -> &::protobuf::well_known_types::StringValue {
        self.name.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue description = 3;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.description.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_description(&self) -> &::protobuf::well_known_types::StringValue {
        self.description.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue lang_tag = 4;

    pub fn clear_lang_tag(&mut self) {
        self.lang_tag.clear();
    }

    pub fn has_lang_tag(&self) -> bool {
        self.lang_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lang_tag(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.lang_tag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang_tag(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.lang_tag.is_none() {
            self.lang_tag.set_default();
        }
        self.lang_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_lang_tag(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.lang_tag.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_lang_tag(&self) -> &::protobuf::well_known_types::StringValue {
        self.lang_tag.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue avatar_url = 5;

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.avatar_url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.avatar_url.is_none() {
            self.avatar_url.set_default();
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.avatar_url.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_avatar_url(&self) -> &::protobuf::well_known_types::StringValue {
        self.avatar_url.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.BoolValue open = 6;

    pub fn clear_open(&mut self) {
        self.open.clear();
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.open = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_open(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.open.is_none() {
            self.open.set_default();
        }
        self.open.as_mut().unwrap()
    }

    // Take field
    pub fn take_open(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.open.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    pub fn get_open(&self) -> &::protobuf::well_known_types::BoolValue {
        self.open.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
}

impl ::protobuf::Message for UpdateGroupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lang_tag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar_url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.open {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lang_tag)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.open)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group_id);
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lang_tag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.open.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.group_id.is_empty() {
            os.write_string(1, &self.group_id)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lang_tag.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.avatar_url.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.open.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateGroupRequest {
        UpdateGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group_id",
                    |m: &UpdateGroupRequest| { &m.group_id },
                    |m: &mut UpdateGroupRequest| { &mut m.group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "name",
                    |m: &UpdateGroupRequest| { &m.name },
                    |m: &mut UpdateGroupRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "description",
                    |m: &UpdateGroupRequest| { &m.description },
                    |m: &mut UpdateGroupRequest| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "lang_tag",
                    |m: &UpdateGroupRequest| { &m.lang_tag },
                    |m: &mut UpdateGroupRequest| { &mut m.lang_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "avatar_url",
                    |m: &UpdateGroupRequest| { &m.avatar_url },
                    |m: &mut UpdateGroupRequest| { &mut m.avatar_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "open",
                    |m: &UpdateGroupRequest| { &m.open },
                    |m: &mut UpdateGroupRequest| { &mut m.open },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateGroupRequest>(
                    "UpdateGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateGroupRequest,
        };
        unsafe {
            instance.get(UpdateGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateGroupRequest {
    fn clear(&mut self) {
        self.clear_group_id();
        self.clear_name();
        self.clear_description();
        self.clear_lang_tag();
        self.clear_avatar_url();
        self.clear_open();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub id: ::std::string::String,
    pub username: ::std::string::String,
    pub display_name: ::std::string::String,
    pub avatar_url: ::std::string::String,
    pub lang_tag: ::std::string::String,
    pub location: ::std::string::String,
    pub timezone: ::std::string::String,
    pub metadata: ::std::string::String,
    pub facebook_id: ::std::string::String,
    pub google_id: ::std::string::String,
    pub gamecenter_id: ::std::string::String,
    pub steam_id: ::std::string::String,
    pub online: bool,
    pub edge_count: i32,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // string display_name = 3;

    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }

    // string avatar_url = 4;

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        &mut self.avatar_url
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar_url, ::std::string::String::new())
    }

    pub fn get_avatar_url(&self) -> &str {
        &self.avatar_url
    }

    // string lang_tag = 5;

    pub fn clear_lang_tag(&mut self) {
        self.lang_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_lang_tag(&mut self, v: ::std::string::String) {
        self.lang_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lang_tag(&mut self) -> &mut ::std::string::String {
        &mut self.lang_tag
    }

    // Take field
    pub fn take_lang_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lang_tag, ::std::string::String::new())
    }

    pub fn get_lang_tag(&self) -> &str {
        &self.lang_tag
    }

    // string location = 6;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    pub fn get_location(&self) -> &str {
        &self.location
    }

    // string timezone = 7;

    pub fn clear_timezone(&mut self) {
        self.timezone.clear();
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: ::std::string::String) {
        self.timezone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timezone(&mut self) -> &mut ::std::string::String {
        &mut self.timezone
    }

    // Take field
    pub fn take_timezone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timezone, ::std::string::String::new())
    }

    pub fn get_timezone(&self) -> &str {
        &self.timezone
    }

    // string metadata = 8;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }

    // string facebook_id = 9;

    pub fn clear_facebook_id(&mut self) {
        self.facebook_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_facebook_id(&mut self, v: ::std::string::String) {
        self.facebook_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_facebook_id(&mut self) -> &mut ::std::string::String {
        &mut self.facebook_id
    }

    // Take field
    pub fn take_facebook_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.facebook_id, ::std::string::String::new())
    }

    pub fn get_facebook_id(&self) -> &str {
        &self.facebook_id
    }

    // string google_id = 10;

    pub fn clear_google_id(&mut self) {
        self.google_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_google_id(&mut self, v: ::std::string::String) {
        self.google_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_google_id(&mut self) -> &mut ::std::string::String {
        &mut self.google_id
    }

    // Take field
    pub fn take_google_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.google_id, ::std::string::String::new())
    }

    pub fn get_google_id(&self) -> &str {
        &self.google_id
    }

    // string gamecenter_id = 11;

    pub fn clear_gamecenter_id(&mut self) {
        self.gamecenter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gamecenter_id(&mut self, v: ::std::string::String) {
        self.gamecenter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamecenter_id(&mut self) -> &mut ::std::string::String {
        &mut self.gamecenter_id
    }

    // Take field
    pub fn take_gamecenter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gamecenter_id, ::std::string::String::new())
    }

    pub fn get_gamecenter_id(&self) -> &str {
        &self.gamecenter_id
    }

    // string steam_id = 12;

    pub fn clear_steam_id(&mut self) {
        self.steam_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: ::std::string::String) {
        self.steam_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steam_id(&mut self) -> &mut ::std::string::String {
        &mut self.steam_id
    }

    // Take field
    pub fn take_steam_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.steam_id, ::std::string::String::new())
    }

    pub fn get_steam_id(&self) -> &str {
        &self.steam_id
    }

    // bool online = 13;

    pub fn clear_online(&mut self) {
        self.online = false;
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: bool) {
        self.online = v;
    }

    pub fn get_online(&self) -> bool {
        self.online
    }

    // int32 edge_count = 14;

    pub fn clear_edge_count(&mut self) {
        self.edge_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_count(&mut self, v: i32) {
        self.edge_count = v;
    }

    pub fn get_edge_count(&self) -> i32 {
        self.edge_count
    }

    // .google.protobuf.Timestamp create_time = 15;

    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp update_time = 16;

    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar_url)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lang_tag)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timezone)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.facebook_id)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.google_id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gamecenter_id)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.steam_id)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edge_count = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.display_name);
        }
        if !self.avatar_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.avatar_url);
        }
        if !self.lang_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.lang_tag);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.location);
        }
        if !self.timezone.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.timezone);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.metadata);
        }
        if !self.facebook_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.facebook_id);
        }
        if !self.google_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.google_id);
        }
        if !self.gamecenter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.gamecenter_id);
        }
        if !self.steam_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.steam_id);
        }
        if self.online != false {
            my_size += 2;
        }
        if self.edge_count != 0 {
            my_size += ::protobuf::rt::value_size(14, self.edge_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(3, &self.display_name)?;
        }
        if !self.avatar_url.is_empty() {
            os.write_string(4, &self.avatar_url)?;
        }
        if !self.lang_tag.is_empty() {
            os.write_string(5, &self.lang_tag)?;
        }
        if !self.location.is_empty() {
            os.write_string(6, &self.location)?;
        }
        if !self.timezone.is_empty() {
            os.write_string(7, &self.timezone)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(8, &self.metadata)?;
        }
        if !self.facebook_id.is_empty() {
            os.write_string(9, &self.facebook_id)?;
        }
        if !self.google_id.is_empty() {
            os.write_string(10, &self.google_id)?;
        }
        if !self.gamecenter_id.is_empty() {
            os.write_string(11, &self.gamecenter_id)?;
        }
        if !self.steam_id.is_empty() {
            os.write_string(12, &self.steam_id)?;
        }
        if self.online != false {
            os.write_bool(13, self.online)?;
        }
        if self.edge_count != 0 {
            os.write_int32(14, self.edge_count)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &User| { &m.id },
                    |m: &mut User| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &User| { &m.username },
                    |m: &mut User| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "display_name",
                    |m: &User| { &m.display_name },
                    |m: &mut User| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "avatar_url",
                    |m: &User| { &m.avatar_url },
                    |m: &mut User| { &mut m.avatar_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lang_tag",
                    |m: &User| { &m.lang_tag },
                    |m: &mut User| { &mut m.lang_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location",
                    |m: &User| { &m.location },
                    |m: &mut User| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timezone",
                    |m: &User| { &m.timezone },
                    |m: &mut User| { &mut m.timezone },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &User| { &m.metadata },
                    |m: &mut User| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "facebook_id",
                    |m: &User| { &m.facebook_id },
                    |m: &mut User| { &mut m.facebook_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "google_id",
                    |m: &User| { &m.google_id },
                    |m: &mut User| { &mut m.google_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gamecenter_id",
                    |m: &User| { &m.gamecenter_id },
                    |m: &mut User| { &mut m.gamecenter_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "steam_id",
                    |m: &User| { &m.steam_id },
                    |m: &mut User| { &mut m.steam_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "online",
                    |m: &User| { &m.online },
                    |m: &mut User| { &mut m.online },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_count",
                    |m: &User| { &m.edge_count },
                    |m: &mut User| { &mut m.edge_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &User| { &m.create_time },
                    |m: &mut User| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "update_time",
                    |m: &User| { &m.update_time },
                    |m: &mut User| { &mut m.update_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<User>(
                    "User",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static User {
        static mut instance: ::protobuf::lazy::Lazy<User> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const User,
        };
        unsafe {
            instance.get(User::new)
        }
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_username();
        self.clear_display_name();
        self.clear_avatar_url();
        self.clear_lang_tag();
        self.clear_location();
        self.clear_timezone();
        self.clear_metadata();
        self.clear_facebook_id();
        self.clear_google_id();
        self.clear_gamecenter_id();
        self.clear_steam_id();
        self.clear_online();
        self.clear_edge_count();
        self.clear_create_time();
        self.clear_update_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserGroupList {
    // message fields
    pub user_groups: ::protobuf::RepeatedField<UserGroupList_UserGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UserGroupList {
    pub fn new() -> UserGroupList {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.UserGroupList.UserGroup user_groups = 1;

    pub fn clear_user_groups(&mut self) {
        self.user_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_groups(&mut self, v: ::protobuf::RepeatedField<UserGroupList_UserGroup>) {
        self.user_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_groups(&mut self) -> &mut ::protobuf::RepeatedField<UserGroupList_UserGroup> {
        &mut self.user_groups
    }

    // Take field
    pub fn take_user_groups(&mut self) -> ::protobuf::RepeatedField<UserGroupList_UserGroup> {
        ::std::mem::replace(&mut self.user_groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_user_groups(&self) -> &[UserGroupList_UserGroup] {
        &self.user_groups
    }
}

impl ::protobuf::Message for UserGroupList {
    fn is_initialized(&self) -> bool {
        for v in &self.user_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.user_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.user_groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserGroupList {
        UserGroupList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserGroupList_UserGroup>>(
                    "user_groups",
                    |m: &UserGroupList| { &m.user_groups },
                    |m: &mut UserGroupList| { &mut m.user_groups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserGroupList>(
                    "UserGroupList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserGroupList {
        static mut instance: ::protobuf::lazy::Lazy<UserGroupList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserGroupList,
        };
        unsafe {
            instance.get(UserGroupList::new)
        }
    }
}

impl ::protobuf::Clear for UserGroupList {
    fn clear(&mut self) {
        self.clear_user_groups();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserGroupList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserGroupList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserGroupList_UserGroup {
    // message fields
    pub group: ::protobuf::SingularPtrField<Group>,
    pub state: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UserGroupList_UserGroup {
    pub fn new() -> UserGroupList_UserGroup {
        ::std::default::Default::default()
    }

    // .nakama.api.Group group = 1;

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: Group) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut Group {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> Group {
        self.group.take().unwrap_or_else(|| Group::new())
    }

    pub fn get_group(&self) -> &Group {
        self.group.as_ref().unwrap_or_else(|| Group::default_instance())
    }

    // .google.protobuf.Int32Value state = 2;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.state.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_state(&self) -> &::protobuf::well_known_types::Int32Value {
        self.state.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for UserGroupList_UserGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserGroupList_UserGroup {
        UserGroupList_UserGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Group>>(
                    "group",
                    |m: &UserGroupList_UserGroup| { &m.group },
                    |m: &mut UserGroupList_UserGroup| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "state",
                    |m: &UserGroupList_UserGroup| { &m.state },
                    |m: &mut UserGroupList_UserGroup| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserGroupList_UserGroup>(
                    "UserGroupList_UserGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserGroupList_UserGroup {
        static mut instance: ::protobuf::lazy::Lazy<UserGroupList_UserGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserGroupList_UserGroup,
        };
        unsafe {
            instance.get(UserGroupList_UserGroup::new)
        }
    }
}

impl ::protobuf::Clear for UserGroupList_UserGroup {
    fn clear(&mut self) {
        self.clear_group();
        self.clear_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserGroupList_UserGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserGroupList_UserGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserGroupList_UserGroup_State {
    SUPERADMIN = 0,
    ADMIN = 1,
    MEMBER = 2,
    JOIN_REQUEST = 3,
}

impl ::protobuf::ProtobufEnum for UserGroupList_UserGroup_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserGroupList_UserGroup_State> {
        match value {
            0 => ::std::option::Option::Some(UserGroupList_UserGroup_State::SUPERADMIN),
            1 => ::std::option::Option::Some(UserGroupList_UserGroup_State::ADMIN),
            2 => ::std::option::Option::Some(UserGroupList_UserGroup_State::MEMBER),
            3 => ::std::option::Option::Some(UserGroupList_UserGroup_State::JOIN_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserGroupList_UserGroup_State] = &[
            UserGroupList_UserGroup_State::SUPERADMIN,
            UserGroupList_UserGroup_State::ADMIN,
            UserGroupList_UserGroup_State::MEMBER,
            UserGroupList_UserGroup_State::JOIN_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UserGroupList_UserGroup_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UserGroupList_UserGroup_State {
}

impl ::std::default::Default for UserGroupList_UserGroup_State {
    fn default() -> Self {
        UserGroupList_UserGroup_State::SUPERADMIN
    }
}

impl ::protobuf::reflect::ProtobufValue for UserGroupList_UserGroup_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Users {
    // message fields
    pub users: ::protobuf::RepeatedField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Users {
    pub fn new() -> Users {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.User users = 1;

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    pub fn get_users(&self) -> &[User] {
        &self.users
    }
}

impl ::protobuf::Message for Users {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Users {
        Users::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                    "users",
                    |m: &Users| { &m.users },
                    |m: &mut Users| { &mut m.users },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Users>(
                    "Users",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Users {
        static mut instance: ::protobuf::lazy::Lazy<Users> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Users,
        };
        unsafe {
            instance.get(Users::new)
        }
    }
}

impl ::protobuf::Clear for Users {
    fn clear(&mut self) {
        self.clear_users();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Users {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Users {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLeaderboardRecordRequest {
    // message fields
    pub leaderboard_id: ::std::string::String,
    pub record: ::protobuf::SingularPtrField<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteLeaderboardRecordRequest {
    pub fn new() -> WriteLeaderboardRecordRequest {
        ::std::default::Default::default()
    }

    // string leaderboard_id = 1;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: ::std::string::String) {
        self.leaderboard_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_id(&mut self) -> &mut ::std::string::String {
        &mut self.leaderboard_id
    }

    // Take field
    pub fn take_leaderboard_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.leaderboard_id, ::std::string::String::new())
    }

    pub fn get_leaderboard_id(&self) -> &str {
        &self.leaderboard_id
    }

    // .nakama.api.WriteLeaderboardRecordRequest.LeaderboardRecordWrite record = 2;

    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    pub fn has_record(&self) -> bool {
        self.record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: WriteLeaderboardRecordRequest_LeaderboardRecordWrite) {
        self.record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        if self.record.is_none() {
            self.record.set_default();
        }
        self.record.as_mut().unwrap()
    }

    // Take field
    pub fn take_record(&mut self) -> WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        self.record.take().unwrap_or_else(|| WriteLeaderboardRecordRequest_LeaderboardRecordWrite::new())
    }

    pub fn get_record(&self) -> &WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        self.record.as_ref().unwrap_or_else(|| WriteLeaderboardRecordRequest_LeaderboardRecordWrite::default_instance())
    }
}

impl ::protobuf::Message for WriteLeaderboardRecordRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.record {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.leaderboard_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.record)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.leaderboard_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.leaderboard_id);
        }
        if let Some(ref v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.leaderboard_id.is_empty() {
            os.write_string(1, &self.leaderboard_id)?;
        }
        if let Some(ref v) = self.record.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLeaderboardRecordRequest {
        WriteLeaderboardRecordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "leaderboard_id",
                    |m: &WriteLeaderboardRecordRequest| { &m.leaderboard_id },
                    |m: &mut WriteLeaderboardRecordRequest| { &mut m.leaderboard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>>(
                    "record",
                    |m: &WriteLeaderboardRecordRequest| { &m.record },
                    |m: &mut WriteLeaderboardRecordRequest| { &mut m.record },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteLeaderboardRecordRequest>(
                    "WriteLeaderboardRecordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteLeaderboardRecordRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteLeaderboardRecordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteLeaderboardRecordRequest,
        };
        unsafe {
            instance.get(WriteLeaderboardRecordRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteLeaderboardRecordRequest {
    fn clear(&mut self) {
        self.clear_leaderboard_id();
        self.clear_record();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLeaderboardRecordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLeaderboardRecordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    // message fields
    pub score: i64,
    pub subscore: i64,
    pub metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    pub fn new() -> WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        ::std::default::Default::default()
    }

    // int64 score = 1;

    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i64) {
        self.score = v;
    }

    pub fn get_score(&self) -> i64 {
        self.score
    }

    // int64 subscore = 2;

    pub fn clear_subscore(&mut self) {
        self.subscore = 0;
    }

    // Param is passed by value, moved
    pub fn set_subscore(&mut self, v: i64) {
        self.subscore = v;
    }

    pub fn get_subscore(&self) -> i64 {
        self.subscore
    }

    // string metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
}

impl ::protobuf::Message for WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.score = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.subscore = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(1, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.subscore != 0 {
            my_size += ::protobuf::rt::value_size(2, self.subscore, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.score != 0 {
            os.write_int64(1, self.score)?;
        }
        if self.subscore != 0 {
            os.write_int64(2, self.subscore)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(3, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        WriteLeaderboardRecordRequest_LeaderboardRecordWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "score",
                    |m: &WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &m.score },
                    |m: &mut WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "subscore",
                    |m: &WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &m.subscore },
                    |m: &mut WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &mut m.subscore },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &m.metadata },
                    |m: &mut WriteLeaderboardRecordRequest_LeaderboardRecordWrite| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>(
                    "WriteLeaderboardRecordRequest_LeaderboardRecordWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
        static mut instance: ::protobuf::lazy::Lazy<WriteLeaderboardRecordRequest_LeaderboardRecordWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteLeaderboardRecordRequest_LeaderboardRecordWrite,
        };
        unsafe {
            instance.get(WriteLeaderboardRecordRequest_LeaderboardRecordWrite::new)
        }
    }
}

impl ::protobuf::Clear for WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    fn clear(&mut self) {
        self.clear_score();
        self.clear_subscore();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStorageObject {
    // message fields
    pub collection: ::std::string::String,
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    pub version: ::std::string::String,
    pub permission_read: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub permission_write: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteStorageObject {
    pub fn new() -> WriteStorageObject {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        &self.key
    }

    // string value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // string version = 4;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // .google.protobuf.Int32Value permission_read = 5;

    pub fn clear_permission_read(&mut self) {
        self.permission_read.clear();
    }

    pub fn has_permission_read(&self) -> bool {
        self.permission_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_read(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.permission_read = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_read(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.permission_read.is_none() {
            self.permission_read.set_default();
        }
        self.permission_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission_read(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.permission_read.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_permission_read(&self) -> &::protobuf::well_known_types::Int32Value {
        self.permission_read.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.Int32Value permission_write = 6;

    pub fn clear_permission_write(&mut self) {
        self.permission_write.clear();
    }

    pub fn has_permission_write(&self) -> bool {
        self.permission_write.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_write(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.permission_write = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_write(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.permission_write.is_none() {
            self.permission_write.set_default();
        }
        self.permission_write.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission_write(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.permission_write.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_permission_write(&self) -> &::protobuf::well_known_types::Int32Value {
        self.permission_write.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for WriteStorageObject {
    fn is_initialized(&self) -> bool {
        for v in &self.permission_read {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permission_write {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission_read)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission_write)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version);
        }
        if let Some(ref v) = self.permission_read.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.permission_write.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        if !self.version.is_empty() {
            os.write_string(4, &self.version)?;
        }
        if let Some(ref v) = self.permission_read.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.permission_write.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStorageObject {
        WriteStorageObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &WriteStorageObject| { &m.collection },
                    |m: &mut WriteStorageObject| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &WriteStorageObject| { &m.key },
                    |m: &mut WriteStorageObject| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &WriteStorageObject| { &m.value },
                    |m: &mut WriteStorageObject| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &WriteStorageObject| { &m.version },
                    |m: &mut WriteStorageObject| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "permission_read",
                    |m: &WriteStorageObject| { &m.permission_read },
                    |m: &mut WriteStorageObject| { &mut m.permission_read },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "permission_write",
                    |m: &WriteStorageObject| { &m.permission_write },
                    |m: &mut WriteStorageObject| { &mut m.permission_write },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteStorageObject>(
                    "WriteStorageObject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStorageObject {
        static mut instance: ::protobuf::lazy::Lazy<WriteStorageObject> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteStorageObject,
        };
        unsafe {
            instance.get(WriteStorageObject::new)
        }
    }
}

impl ::protobuf::Clear for WriteStorageObject {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_key();
        self.clear_value();
        self.clear_version();
        self.clear_permission_read();
        self.clear_permission_write();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStorageObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStorageObject {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteStorageObjectsRequest {
    // message fields
    pub objects: ::protobuf::RepeatedField<WriteStorageObject>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteStorageObjectsRequest {
    pub fn new() -> WriteStorageObjectsRequest {
        ::std::default::Default::default()
    }

    // repeated .nakama.api.WriteStorageObject objects = 1;

    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<WriteStorageObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<WriteStorageObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<WriteStorageObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }

    pub fn get_objects(&self) -> &[WriteStorageObject] {
        &self.objects
    }
}

impl ::protobuf::Message for WriteStorageObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.objects {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteStorageObjectsRequest {
        WriteStorageObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WriteStorageObject>>(
                    "objects",
                    |m: &WriteStorageObjectsRequest| { &m.objects },
                    |m: &mut WriteStorageObjectsRequest| { &mut m.objects },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteStorageObjectsRequest>(
                    "WriteStorageObjectsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteStorageObjectsRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteStorageObjectsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteStorageObjectsRequest,
        };
        unsafe {
            instance.get(WriteStorageObjectsRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteStorageObjectsRequest {
    fn clear(&mut self) {
        self.clear_objects();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteStorageObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteStorageObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteTournamentRecordRequest {
    // message fields
    pub tournament_id: ::std::string::String,
    pub record: ::protobuf::SingularPtrField<WriteTournamentRecordRequest_TournamentRecordWrite>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteTournamentRecordRequest {
    pub fn new() -> WriteTournamentRecordRequest {
        ::std::default::Default::default()
    }

    // string tournament_id = 1;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: ::std::string::String) {
        self.tournament_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_id(&mut self) -> &mut ::std::string::String {
        &mut self.tournament_id
    }

    // Take field
    pub fn take_tournament_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tournament_id, ::std::string::String::new())
    }

    pub fn get_tournament_id(&self) -> &str {
        &self.tournament_id
    }

    // .nakama.api.WriteTournamentRecordRequest.TournamentRecordWrite record = 2;

    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    pub fn has_record(&self) -> bool {
        self.record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: WriteTournamentRecordRequest_TournamentRecordWrite) {
        self.record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut WriteTournamentRecordRequest_TournamentRecordWrite {
        if self.record.is_none() {
            self.record.set_default();
        }
        self.record.as_mut().unwrap()
    }

    // Take field
    pub fn take_record(&mut self) -> WriteTournamentRecordRequest_TournamentRecordWrite {
        self.record.take().unwrap_or_else(|| WriteTournamentRecordRequest_TournamentRecordWrite::new())
    }

    pub fn get_record(&self) -> &WriteTournamentRecordRequest_TournamentRecordWrite {
        self.record.as_ref().unwrap_or_else(|| WriteTournamentRecordRequest_TournamentRecordWrite::default_instance())
    }
}

impl ::protobuf::Message for WriteTournamentRecordRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.record {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tournament_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.record)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tournament_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tournament_id);
        }
        if let Some(ref v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tournament_id.is_empty() {
            os.write_string(1, &self.tournament_id)?;
        }
        if let Some(ref v) = self.record.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteTournamentRecordRequest {
        WriteTournamentRecordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_id",
                    |m: &WriteTournamentRecordRequest| { &m.tournament_id },
                    |m: &mut WriteTournamentRecordRequest| { &mut m.tournament_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WriteTournamentRecordRequest_TournamentRecordWrite>>(
                    "record",
                    |m: &WriteTournamentRecordRequest| { &m.record },
                    |m: &mut WriteTournamentRecordRequest| { &mut m.record },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteTournamentRecordRequest>(
                    "WriteTournamentRecordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteTournamentRecordRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteTournamentRecordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteTournamentRecordRequest,
        };
        unsafe {
            instance.get(WriteTournamentRecordRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteTournamentRecordRequest {
    fn clear(&mut self) {
        self.clear_tournament_id();
        self.clear_record();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteTournamentRecordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteTournamentRecordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteTournamentRecordRequest_TournamentRecordWrite {
    // message fields
    pub score: i64,
    pub subscore: i64,
    pub metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WriteTournamentRecordRequest_TournamentRecordWrite {
    pub fn new() -> WriteTournamentRecordRequest_TournamentRecordWrite {
        ::std::default::Default::default()
    }

    // int64 score = 1;

    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i64) {
        self.score = v;
    }

    pub fn get_score(&self) -> i64 {
        self.score
    }

    // int64 subscore = 2;

    pub fn clear_subscore(&mut self) {
        self.subscore = 0;
    }

    // Param is passed by value, moved
    pub fn set_subscore(&mut self, v: i64) {
        self.subscore = v;
    }

    pub fn get_subscore(&self) -> i64 {
        self.subscore
    }

    // string metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
}

impl ::protobuf::Message for WriteTournamentRecordRequest_TournamentRecordWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.score = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.subscore = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(1, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.subscore != 0 {
            my_size += ::protobuf::rt::value_size(2, self.subscore, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.score != 0 {
            os.write_int64(1, self.score)?;
        }
        if self.subscore != 0 {
            os.write_int64(2, self.subscore)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(3, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteTournamentRecordRequest_TournamentRecordWrite {
        WriteTournamentRecordRequest_TournamentRecordWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "score",
                    |m: &WriteTournamentRecordRequest_TournamentRecordWrite| { &m.score },
                    |m: &mut WriteTournamentRecordRequest_TournamentRecordWrite| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "subscore",
                    |m: &WriteTournamentRecordRequest_TournamentRecordWrite| { &m.subscore },
                    |m: &mut WriteTournamentRecordRequest_TournamentRecordWrite| { &mut m.subscore },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &WriteTournamentRecordRequest_TournamentRecordWrite| { &m.metadata },
                    |m: &mut WriteTournamentRecordRequest_TournamentRecordWrite| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteTournamentRecordRequest_TournamentRecordWrite>(
                    "WriteTournamentRecordRequest_TournamentRecordWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteTournamentRecordRequest_TournamentRecordWrite {
        static mut instance: ::protobuf::lazy::Lazy<WriteTournamentRecordRequest_TournamentRecordWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteTournamentRecordRequest_TournamentRecordWrite,
        };
        unsafe {
            instance.get(WriteTournamentRecordRequest_TournamentRecordWrite::new)
        }
    }
}

impl ::protobuf::Clear for WriteTournamentRecordRequest_TournamentRecordWrite {
    fn clear(&mut self) {
        self.clear_score();
        self.clear_subscore();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteTournamentRecordRequest_TournamentRecordWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteTournamentRecordRequest_TournamentRecordWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*github.com/heroiclabs/nakama/api/api.proto\x12\nnakama.api\x1a\x1fgoo\
    gle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xec\
    \x01\n\x07Account\x12$\n\x04user\x18\x01\x20\x01(\x0b2\x10.nakama.api.Us\
    erR\x04user\x12\x16\n\x06wallet\x18\x02\x20\x01(\tR\x06wallet\x12\x14\n\
    \x05email\x18\x03\x20\x01(\tR\x05email\x123\n\x07devices\x18\x04\x20\x03\
    (\x0b2\x19.nakama.api.AccountDeviceR\x07devices\x12\x1b\n\tcustom_id\x18\
    \x05\x20\x01(\tR\x08customId\x12;\n\x0bverify_time\x18\x06\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\nverifyTime\"\x1f\n\rAccountCustom\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x1f\n\rAccountDevice\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\"@\n\x0cAccountEmail\x12\x14\n\x05email\
    \x18\x01\x20\x01(\tR\x05email\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\
    \x08password\"'\n\x0fAccountFacebook\x12\x14\n\x05token\x18\x01\x20\x01(\
    \tR\x05token\"\xd2\x01\n\x11AccountGameCenter\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x01(\tR\x08playerId\x12\x1b\n\tbundle_id\x18\x02\x20\x01(\tR\
    \x08bundleId\x12+\n\x11timestamp_seconds\x18\x03\x20\x01(\x03R\x10timest\
    ampSeconds\x12\x12\n\x04salt\x18\x04\x20\x01(\tR\x04salt\x12\x1c\n\tsign\
    ature\x18\x05\x20\x01(\tR\tsignature\x12$\n\x0epublic_key_url\x18\x06\
    \x20\x01(\tR\x0cpublicKeyUrl\"%\n\rAccountGoogle\x12\x14\n\x05token\x18\
    \x01\x20\x01(\tR\x05token\"$\n\x0cAccountSteam\x12\x14\n\x05token\x18\
    \x01\x20\x01(\tR\x05token\"C\n\x11AddFriendsRequest\x12\x10\n\x03ids\x18\
    \x01\x20\x03(\tR\x03ids\x12\x1c\n\tusernames\x18\x02\x20\x03(\tR\tuserna\
    mes\"L\n\x14AddGroupUsersRequest\x12\x19\n\x08group_id\x18\x01\x20\x01(\
    \tR\x07groupId\x12\x19\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIds\"\
    \xa0\x01\n\x19AuthenticateCustomRequest\x123\n\x07account\x18\x01\x20\
    \x01(\x0b2\x19.nakama.api.AccountCustomR\x07account\x122\n\x06create\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x06create\x12\x1a\n\
    \x08username\x18\x03\x20\x01(\tR\x08username\"\xa0\x01\n\x19Authenticate\
    DeviceRequest\x123\n\x07account\x18\x01\x20\x01(\x0b2\x19.nakama.api.Acc\
    ountDeviceR\x07account\x122\n\x06create\x18\x02\x20\x01(\x0b2\x1a.google\
    .protobuf.BoolValueR\x06create\x12\x1a\n\x08username\x18\x03\x20\x01(\tR\
    \x08username\"\x9e\x01\n\x18AuthenticateEmailRequest\x122\n\x07account\
    \x18\x01\x20\x01(\x0b2\x18.nakama.api.AccountEmailR\x07account\x122\n\
    \x06create\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x06creat\
    e\x12\x1a\n\x08username\x18\x03\x20\x01(\tR\x08username\"\xd4\x01\n\x1bA\
    uthenticateFacebookRequest\x125\n\x07account\x18\x01\x20\x01(\x0b2\x1b.n\
    akama.api.AccountFacebookR\x07account\x122\n\x06create\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.BoolValueR\x06create\x12\x1a\n\x08username\x18\
    \x03\x20\x01(\tR\x08username\x12.\n\x04sync\x18\x04\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.BoolValueR\x04sync\"\xa8\x01\n\x1dAuthenticateGameCenterRe\
    quest\x127\n\x07account\x18\x01\x20\x01(\x0b2\x1d.nakama.api.AccountGame\
    CenterR\x07account\x122\n\x06create\x18\x02\x20\x01(\x0b2\x1a.google.pro\
    tobuf.BoolValueR\x06create\x12\x1a\n\x08username\x18\x03\x20\x01(\tR\x08\
    username\"\xa0\x01\n\x19AuthenticateGoogleRequest\x123\n\x07account\x18\
    \x01\x20\x01(\x0b2\x19.nakama.api.AccountGoogleR\x07account\x122\n\x06cr\
    eate\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x06create\x12\
    \x1a\n\x08username\x18\x03\x20\x01(\tR\x08username\"\x9e\x01\n\x18Authen\
    ticateSteamRequest\x122\n\x07account\x18\x01\x20\x01(\x0b2\x18.nakama.ap\
    i.AccountSteamR\x07account\x122\n\x06create\x18\x02\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.BoolValueR\x06create\x12\x1a\n\x08username\x18\x03\x20\x01\
    (\tR\x08username\"E\n\x13BlockFriendsRequest\x12\x10\n\x03ids\x18\x01\
    \x20\x03(\tR\x03ids\x12\x1c\n\tusernames\x18\x02\x20\x03(\tR\tusernames\
    \"\x88\x03\n\x0eChannelMessage\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\tR\
    \tchannelId\x12\x1d\n\nmessage_id\x18\x02\x20\x01(\tR\tmessageId\x12/\n\
    \x04code\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x04code\
    \x12\x1b\n\tsender_id\x18\x04\x20\x01(\tR\x08senderId\x12\x1a\n\x08usern\
    ame\x18\x05\x20\x01(\tR\x08username\x12\x18\n\x07content\x18\x06\x20\x01\
    (\tR\x07content\x12;\n\x0bcreate_time\x18\x07\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\ncreateTime\x12;\n\x0bupdate_time\x18\x08\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nupdateTime\x12:\n\npersistent\x18\
    \t\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\npersistent\"\x8e\x01\n\
    \x12ChannelMessageList\x126\n\x08messages\x18\x01\x20\x03(\x0b2\x1a.naka\
    ma.api.ChannelMessageR\x08messages\x12\x1f\n\x0bnext_cursor\x18\x02\x20\
    \x01(\tR\nnextCursor\x12\x1f\n\x0bprev_cursor\x18\x03\x20\x01(\tR\nprevC\
    ursor\"\x98\x01\n\x12CreateGroupRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescrip\
    tion\x12\x19\n\x08lang_tag\x18\x03\x20\x01(\tR\x07langTag\x12\x1d\n\nava\
    tar_url\x18\x04\x20\x01(\tR\tavatarUrl\x12\x12\n\x04open\x18\x05\x20\x01\
    (\x08R\x04open\"F\n\x14DeleteFriendsRequest\x12\x10\n\x03ids\x18\x01\x20\
    \x03(\tR\x03ids\x12\x1c\n\tusernames\x18\x02\x20\x03(\tR\tusernames\"/\n\
    \x12DeleteGroupRequest\x12\x19\n\x08group_id\x18\x01\x20\x01(\tR\x07grou\
    pId\"G\n\x1eDeleteLeaderboardRecordRequest\x12%\n\x0eleaderboard_id\x18\
    \x01\x20\x01(\tR\rleaderboardId\".\n\x1aDeleteNotificationsRequest\x12\
    \x10\n\x03ids\x18\x01\x20\x03(\tR\x03ids\"c\n\x15DeleteStorageObjectId\
    \x12\x1e\n\ncollection\x18\x01\x20\x01(\tR\ncollection\x12\x10\n\x03key\
    \x18\x02\x20\x01(\tR\x03key\x12\x18\n\x07version\x18\x03\x20\x01(\tR\x07\
    version\"_\n\x1bDeleteStorageObjectsRequest\x12@\n\nobject_ids\x18\x01\
    \x20\x03(\x0b2!.nakama.api.DeleteStorageObjectIdR\tobjectIds\"\xd7\x01\n\
    \x05Event\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12A\n\nproperti\
    es\x18\x02\x20\x03(\x0b2!.nakama.api.Event.PropertiesEntryR\nproperties\
    \x128\n\ttimestamp\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \ttimestamp\x1a=\n\x0fPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\
    \xa9\x01\n\x06Friend\x12$\n\x04user\x18\x01\x20\x01(\x0b2\x10.nakama.api\
    .UserR\x04user\x121\n\x05state\x18\x02\x20\x01(\x0b2\x1b.google.protobuf\
    .Int32ValueR\x05state\"F\n\x05State\x12\n\n\x06FRIEND\x10\0\x12\x0f\n\
    \x0bINVITE_SENT\x10\x01\x12\x13\n\x0fINVITE_RECEIVED\x10\x02\x12\x0b\n\
    \x07BLOCKED\x10\x03\"7\n\x07Friends\x12,\n\x07friends\x18\x01\x20\x03(\
    \x0b2\x12.nakama.api.FriendR\x07friends\"d\n\x0fGetUsersRequest\x12\x10\
    \n\x03ids\x18\x01\x20\x03(\tR\x03ids\x12\x1c\n\tusernames\x18\x02\x20\
    \x03(\tR\tusernames\x12!\n\x0cfacebook_ids\x18\x03\x20\x03(\tR\x0bfacebo\
    okIds\"\xa8\x03\n\x05Group\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x1d\n\ncreator_id\x18\x02\x20\x01(\tR\tcreatorId\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\
    \x0bdescription\x12\x19\n\x08lang_tag\x18\x05\x20\x01(\tR\x07langTag\x12\
    \x1a\n\x08metadata\x18\x06\x20\x01(\tR\x08metadata\x12\x1d\n\navatar_url\
    \x18\x07\x20\x01(\tR\tavatarUrl\x12.\n\x04open\x18\x08\x20\x01(\x0b2\x1a\
    .google.protobuf.BoolValueR\x04open\x12\x1d\n\nedge_count\x18\t\x20\x01(\
    \x05R\tedgeCount\x12\x1b\n\tmax_count\x18\n\x20\x01(\x05R\x08maxCount\
    \x12;\n\x0bcreate_time\x18\x0b\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\ncreateTime\x12;\n\x0bupdate_time\x18\x0c\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\nupdateTime\"N\n\tGroupList\x12)\n\x06groups\x18\x01\
    \x20\x03(\x0b2\x11.nakama.api.GroupR\x06groups\x12\x16\n\x06cursor\x18\
    \x02\x20\x01(\tR\x06cursor\"\xfe\x01\n\rGroupUserList\x12D\n\x0bgroup_us\
    ers\x18\x01\x20\x03(\x0b2#.nakama.api.GroupUserList.GroupUserR\ngroupUse\
    rs\x1a\xa6\x01\n\tGroupUser\x12$\n\x04user\x18\x01\x20\x01(\x0b2\x10.nak\
    ama.api.UserR\x04user\x121\n\x05state\x18\x02\x20\x01(\x0b2\x1b.google.p\
    rotobuf.Int32ValueR\x05state\"@\n\x05State\x12\x0e\n\nSUPERADMIN\x10\0\
    \x12\t\n\x05ADMIN\x10\x01\x12\n\n\x06MEMBER\x10\x02\x12\x10\n\x0cJOIN_RE\
    QUEST\x10\x03\"\x87\x01\n\x1cImportFacebookFriendsRequest\x125\n\x07acco\
    unt\x18\x01\x20\x01(\x0b2\x1b.nakama.api.AccountFacebookR\x07account\x12\
    0\n\x05reset\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x05res\
    et\"-\n\x10JoinGroupRequest\x12\x19\n\x08group_id\x18\x01\x20\x01(\tR\
    \x07groupId\"<\n\x15JoinTournamentRequest\x12#\n\rtournament_id\x18\x01\
    \x20\x01(\tR\x0ctournamentId\"M\n\x15KickGroupUsersRequest\x12\x19\n\x08\
    group_id\x18\x01\x20\x01(\tR\x07groupId\x12\x19\n\x08user_ids\x18\x02\
    \x20\x03(\tR\x07userIds\"\xe9\x03\n\x11LeaderboardRecord\x12%\n\x0eleade\
    rboard_id\x18\x01\x20\x01(\tR\rleaderboardId\x12\x19\n\x08owner_id\x18\
    \x02\x20\x01(\tR\x07ownerId\x128\n\x08username\x18\x03\x20\x01(\x0b2\x1c\
    .google.protobuf.StringValueR\x08username\x12\x14\n\x05score\x18\x04\x20\
    \x01(\x03R\x05score\x12\x1a\n\x08subscore\x18\x05\x20\x01(\x03R\x08subsc\
    ore\x12\x1b\n\tnum_score\x18\x06\x20\x01(\x05R\x08numScore\x12\x1a\n\x08\
    metadata\x18\x07\x20\x01(\tR\x08metadata\x12;\n\x0bcreate_time\x18\x08\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0bupda\
    te_time\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdateTime\
    \x12;\n\x0bexpiry_time\x18\n\x20\x01(\x0b2\x1a.google.protobuf.Timestamp\
    R\nexpiryTime\x12\x12\n\x04rank\x18\x0b\x20\x01(\x03R\x04rank\x12\"\n\rm\
    ax_num_score\x18\x0c\x20\x01(\rR\x0bmaxNumScore\"\xd6\x01\n\x15Leaderboa\
    rdRecordList\x127\n\x07records\x18\x01\x20\x03(\x0b2\x1d.nakama.api.Lead\
    erboardRecordR\x07records\x12B\n\rowner_records\x18\x02\x20\x03(\x0b2\
    \x1d.nakama.api.LeaderboardRecordR\x0cownerRecords\x12\x1f\n\x0bnext_cur\
    sor\x18\x03\x20\x01(\tR\nnextCursor\x12\x1f\n\x0bprev_cursor\x18\x04\x20\
    \x01(\tR\nprevCursor\".\n\x11LeaveGroupRequest\x12\x19\n\x08group_id\x18\
    \x01\x20\x01(\tR\x07groupId\"|\n\x13LinkFacebookRequest\x125\n\x07accoun\
    t\x18\x01\x20\x01(\x0b2\x1b.nakama.api.AccountFacebookR\x07account\x12.\
    \n\x04sync\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x04sync\
    \"\xbc\x01\n\x1aListChannelMessagesRequest\x12\x1d\n\nchannel_id\x18\x01\
    \x20\x01(\tR\tchannelId\x121\n\x05limit\x18\x02\x20\x01(\x0b2\x1b.google\
    .protobuf.Int32ValueR\x05limit\x124\n\x07forward\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x07forward\x12\x16\n\x06cursor\x18\x04\
    \x20\x01(\tR\x06cursor\"r\n\x11ListGroupsRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x16\n\x06cursor\x18\x02\x20\x01(\tR\x06curs\
    or\x121\n\x05limit\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\
    \x05limit\"2\n\x15ListGroupUsersRequest\x12\x19\n\x08group_id\x18\x01\
    \x20\x01(\tR\x07groupId\"\xa0\x01\n(ListLeaderboardRecordsAroundOwnerReq\
    uest\x12%\n\x0eleaderboard_id\x18\x01\x20\x01(\tR\rleaderboardId\x122\n\
    \x05limit\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x05limi\
    t\x12\x19\n\x08owner_id\x18\x03\x20\x01(\tR\x07ownerId\"\xae\x01\n\x1dLi\
    stLeaderboardRecordsRequest\x12%\n\x0eleaderboard_id\x18\x01\x20\x01(\tR\
    \rleaderboardId\x12\x1b\n\towner_ids\x18\x02\x20\x03(\tR\x08ownerIds\x12\
    1\n\x05limit\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05li\
    mit\x12\x16\n\x06cursor\x18\x04\x20\x01(\tR\x06cursor\"\xe1\x02\n\x12Lis\
    tMatchesRequest\x121\n\x05limit\x18\x01\x20\x01(\x0b2\x1b.google.protobu\
    f.Int32ValueR\x05limit\x12@\n\rauthoritative\x18\x02\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.BoolValueR\rauthoritative\x122\n\x05label\x18\x03\x20\x01\
    (\x0b2\x1c.google.protobuf.StringValueR\x05label\x126\n\x08min_size\x18\
    \x04\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x07minSize\x126\n\x08\
    max_size\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x07maxSiz\
    e\x122\n\x05query\x18\x06\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\
    \x05query\"x\n\x18ListNotificationsRequest\x121\n\x05limit\x18\x01\x20\
    \x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05limit\x12)\n\x10cacheable_\
    cursor\x18\x02\x20\x01(\tR\x0fcacheableCursor\"\x9f\x01\n\x19ListStorage\
    ObjectsRequest\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\x12\
    \x1e\n\ncollection\x18\x02\x20\x01(\tR\ncollection\x121\n\x05limit\x18\
    \x03\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05limit\x12\x16\n\
    \x06cursor\x18\x04\x20\x01(\tR\x06cursor\"\x9d\x01\n'ListTournamentRecor\
    dsAroundOwnerRequest\x12#\n\rtournament_id\x18\x01\x20\x01(\tR\x0ctourna\
    mentId\x122\n\x05limit\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32V\
    alueR\x05limit\x12\x19\n\x08owner_id\x18\x03\x20\x01(\tR\x07ownerId\"\
    \xab\x01\n\x1cListTournamentRecordsRequest\x12#\n\rtournament_id\x18\x01\
    \x20\x01(\tR\x0ctournamentId\x12\x1b\n\towner_ids\x18\x02\x20\x03(\tR\
    \x08ownerIds\x121\n\x05limit\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.I\
    nt32ValueR\x05limit\x12\x16\n\x06cursor\x18\x04\x20\x01(\tR\x06cursor\"\
    \xdf\x02\n\x16ListTournamentsRequest\x12C\n\x0ecategory_start\x18\x01\
    \x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\rcategoryStart\x12?\n\
    \x0ccategory_end\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\
    \x0bcategoryEnd\x12;\n\nstart_time\x18\x03\x20\x01(\x0b2\x1c.google.prot\
    obuf.UInt32ValueR\tstartTime\x127\n\x08end_time\x18\x04\x20\x01(\x0b2\
    \x1c.google.protobuf.UInt32ValueR\x07endTime\x121\n\x05limit\x18\x06\x20\
    \x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05limit\x12\x16\n\x06cursor\
    \x18\x08\x20\x01(\tR\x06cursor\"0\n\x15ListUserGroupsRequest\x12\x17\n\
    \x07user_id\x18\x01\x20\x01(\tR\x06userId\"\x90\x01\n\x05Match\x12\x19\n\
    \x08match_id\x18\x01\x20\x01(\tR\x07matchId\x12$\n\rauthoritative\x18\
    \x02\x20\x01(\x08R\rauthoritative\x122\n\x05label\x18\x03\x20\x01(\x0b2\
    \x1c.google.protobuf.StringValueR\x05label\x12\x12\n\x04size\x18\x04\x20\
    \x01(\x05R\x04size\"8\n\tMatchList\x12+\n\x07matches\x18\x01\x20\x03(\
    \x0b2\x11.nakama.api.MatchR\x07matches\"\xe0\x01\n\x0cNotification\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x18\n\x07subject\x18\x02\x20\
    \x01(\tR\x07subject\x12\x18\n\x07content\x18\x03\x20\x01(\tR\x07content\
    \x12\x12\n\x04code\x18\x04\x20\x01(\x05R\x04code\x12\x1b\n\tsender_id\
    \x18\x05\x20\x01(\tR\x08senderId\x12;\n\x0bcreate_time\x18\x06\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12\x1e\n\npersistent\
    \x18\x07\x20\x01(\x08R\npersistent\"}\n\x10NotificationList\x12>\n\rnoti\
    fications\x18\x01\x20\x03(\x0b2\x18.nakama.api.NotificationR\rnotificati\
    ons\x12)\n\x10cacheable_cursor\x18\x02\x20\x01(\tR\x0fcacheableCursor\"P\
    \n\x18PromoteGroupUsersRequest\x12\x19\n\x08group_id\x18\x01\x20\x01(\tR\
    \x07groupId\x12\x19\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIds\"`\n\
    \x13ReadStorageObjectId\x12\x1e\n\ncollection\x18\x01\x20\x01(\tR\ncolle\
    ction\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x17\n\x07user_id\
    \x18\x03\x20\x01(\tR\x06userId\"[\n\x19ReadStorageObjectsRequest\x12>\n\
    \nobject_ids\x18\x01\x20\x03(\x0b2\x1f.nakama.api.ReadStorageObjectIdR\t\
    objectIds\"J\n\x03Rpc\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x18\
    \n\x07payload\x18\x02\x20\x01(\tR\x07payload\x12\x19\n\x08http_key\x18\
    \x03\x20\x01(\tR\x07httpKey\"V\n\x07Session\x12\x18\n\x07created\x18\x01\
    \x20\x01(\x08R\x07created\x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05toke\
    n\x12\x1b\n\tudp_token\x18\x03\x20\x01(\tR\x08udpToken\"\xd8\x02\n\rStor\
    ageObject\x12\x1e\n\ncollection\x18\x01\x20\x01(\tR\ncollection\x12\x10\
    \n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x17\n\x07user_id\x18\x03\x20\
    \x01(\tR\x06userId\x12\x14\n\x05value\x18\x04\x20\x01(\tR\x05value\x12\
    \x18\n\x07version\x18\x05\x20\x01(\tR\x07version\x12'\n\x0fpermission_re\
    ad\x18\x06\x20\x01(\x05R\x0epermissionRead\x12)\n\x10permission_write\
    \x18\x07\x20\x01(\x05R\x0fpermissionWrite\x12;\n\x0bcreate_time\x18\x08\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0bupda\
    te_time\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdateTime\"\
    w\n\x10StorageObjectAck\x12\x1e\n\ncollection\x18\x01\x20\x01(\tR\ncolle\
    ction\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x18\n\x07version\
    \x18\x03\x20\x01(\tR\x07version\x12\x17\n\x07user_id\x18\x04\x20\x01(\tR\
    \x06userId\"E\n\x11StorageObjectAcks\x120\n\x04acks\x18\x01\x20\x03(\x0b\
    2\x1c.nakama.api.StorageObjectAckR\x04acks\"E\n\x0eStorageObjects\x123\n\
    \x07objects\x18\x01\x20\x03(\x0b2\x19.nakama.api.StorageObjectR\x07objec\
    ts\"`\n\x11StorageObjectList\x123\n\x07objects\x18\x01\x20\x03(\x0b2\x19\
    .nakama.api.StorageObjectR\x07objects\x12\x16\n\x06cursor\x18\x02\x20\
    \x01(\tR\x06cursor\"\xa4\x04\n\nTournament\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\n\
    \x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x1a\n\x08category\
    \x18\x04\x20\x01(\rR\x08category\x12\x1d\n\nsort_order\x18\x05\x20\x01(\
    \rR\tsortOrder\x12\x12\n\x04size\x18\x06\x20\x01(\rR\x04size\x12\x19\n\
    \x08max_size\x18\x07\x20\x01(\rR\x07maxSize\x12\"\n\rmax_num_score\x18\
    \x08\x20\x01(\rR\x0bmaxNumScore\x12\x1b\n\tcan_enter\x18\t\x20\x01(\x08R\
    \x08canEnter\x12\x1d\n\nend_active\x18\n\x20\x01(\rR\tendActive\x12\x1d\
    \n\nnext_reset\x18\x0b\x20\x01(\rR\tnextReset\x12\x1a\n\x08metadata\x18\
    \x0c\x20\x01(\tR\x08metadata\x12;\n\x0bcreate_time\x18\r\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ncreateTime\x129\n\nstart_time\x18\x0e\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x125\n\x08end_t\
    ime\x18\x0f\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\x12\
    \x1a\n\x08duration\x18\x10\x20\x01(\rR\x08duration\"b\n\x0eTournamentLis\
    t\x128\n\x0btournaments\x18\x01\x20\x03(\x0b2\x16.nakama.api.TournamentR\
    \x0btournaments\x12\x16\n\x06cursor\x18\x02\x20\x01(\tR\x06cursor\"\xd5\
    \x01\n\x14TournamentRecordList\x127\n\x07records\x18\x01\x20\x03(\x0b2\
    \x1d.nakama.api.LeaderboardRecordR\x07records\x12B\n\rowner_records\x18\
    \x02\x20\x03(\x0b2\x1d.nakama.api.LeaderboardRecordR\x0cownerRecords\x12\
    \x1f\n\x0bnext_cursor\x18\x03\x20\x01(\tR\nnextCursor\x12\x1f\n\x0bprev_\
    cursor\x18\x04\x20\x01(\tR\nprevCursor\"\xfb\x02\n\x14UpdateAccountReque\
    st\x128\n\x08username\x18\x01\x20\x01(\x0b2\x1c.google.protobuf.StringVa\
    lueR\x08username\x12?\n\x0cdisplay_name\x18\x02\x20\x01(\x0b2\x1c.google\
    .protobuf.StringValueR\x0bdisplayName\x12;\n\navatar_url\x18\x03\x20\x01\
    (\x0b2\x1c.google.protobuf.StringValueR\tavatarUrl\x127\n\x08lang_tag\
    \x18\x04\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\x07langTag\x128\
    \n\x08location\x18\x05\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\
    \x08location\x128\n\x08timezone\x18\x06\x20\x01(\x0b2\x1c.google.protobu\
    f.StringValueR\x08timezone\"\xc7\x02\n\x12UpdateGroupRequest\x12\x19\n\
    \x08group_id\x18\x01\x20\x01(\tR\x07groupId\x120\n\x04name\x18\x02\x20\
    \x01(\x0b2\x1c.google.protobuf.StringValueR\x04name\x12>\n\x0bdescriptio\
    n\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\x0bdescription\
    \x127\n\x08lang_tag\x18\x04\x20\x01(\x0b2\x1c.google.protobuf.StringValu\
    eR\x07langTag\x12;\n\navatar_url\x18\x05\x20\x01(\x0b2\x1c.google.protob\
    uf.StringValueR\tavatarUrl\x12.\n\x04open\x18\x06\x20\x01(\x0b2\x1a.goog\
    le.protobuf.BoolValueR\x04open\"\x92\x04\n\x04User\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08user\
    name\x12!\n\x0cdisplay_name\x18\x03\x20\x01(\tR\x0bdisplayName\x12\x1d\n\
    \navatar_url\x18\x04\x20\x01(\tR\tavatarUrl\x12\x19\n\x08lang_tag\x18\
    \x05\x20\x01(\tR\x07langTag\x12\x1a\n\x08location\x18\x06\x20\x01(\tR\
    \x08location\x12\x1a\n\x08timezone\x18\x07\x20\x01(\tR\x08timezone\x12\
    \x1a\n\x08metadata\x18\x08\x20\x01(\tR\x08metadata\x12\x1f\n\x0bfacebook\
    _id\x18\t\x20\x01(\tR\nfacebookId\x12\x1b\n\tgoogle_id\x18\n\x20\x01(\tR\
    \x08googleId\x12#\n\rgamecenter_id\x18\x0b\x20\x01(\tR\x0cgamecenterId\
    \x12\x19\n\x08steam_id\x18\x0c\x20\x01(\tR\x07steamId\x12\x16\n\x06onlin\
    e\x18\r\x20\x01(\x08R\x06online\x12\x1d\n\nedge_count\x18\x0e\x20\x01(\
    \x05R\tedgeCount\x12;\n\x0bcreate_time\x18\x0f\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\ncreateTime\x12;\n\x0bupdate_time\x18\x10\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nupdateTime\"\x81\x02\n\rUserGroupL\
    ist\x12D\n\x0buser_groups\x18\x01\x20\x03(\x0b2#.nakama.api.UserGroupLis\
    t.UserGroupR\nuserGroups\x1a\xa9\x01\n\tUserGroup\x12'\n\x05group\x18\
    \x01\x20\x01(\x0b2\x11.nakama.api.GroupR\x05group\x121\n\x05state\x18\
    \x02\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05state\"@\n\x05Stat\
    e\x12\x0e\n\nSUPERADMIN\x10\0\x12\t\n\x05ADMIN\x10\x01\x12\n\n\x06MEMBER\
    \x10\x02\x12\x10\n\x0cJOIN_REQUEST\x10\x03\"/\n\x05Users\x12&\n\x05users\
    \x18\x01\x20\x03(\x0b2\x10.nakama.api.UserR\x05users\"\x88\x02\n\x1dWrit\
    eLeaderboardRecordRequest\x12%\n\x0eleaderboard_id\x18\x01\x20\x01(\tR\r\
    leaderboardId\x12X\n\x06record\x18\x02\x20\x01(\x0b2@.nakama.api.WriteLe\
    aderboardRecordRequest.LeaderboardRecordWriteR\x06record\x1af\n\x16Leade\
    rboardRecordWrite\x12\x14\n\x05score\x18\x01\x20\x01(\x03R\x05score\x12\
    \x1a\n\x08subscore\x18\x02\x20\x01(\x03R\x08subscore\x12\x1a\n\x08metada\
    ta\x18\x03\x20\x01(\tR\x08metadata\"\x84\x02\n\x12WriteStorageObject\x12\
    \x1e\n\ncollection\x18\x01\x20\x01(\tR\ncollection\x12\x10\n\x03key\x18\
    \x02\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05value\
    \x12\x18\n\x07version\x18\x04\x20\x01(\tR\x07version\x12D\n\x0fpermissio\
    n_read\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x0epermissi\
    onRead\x12F\n\x10permission_write\x18\x06\x20\x01(\x0b2\x1b.google.proto\
    buf.Int32ValueR\x0fpermissionWrite\"V\n\x1aWriteStorageObjectsRequest\
    \x128\n\x07objects\x18\x01\x20\x03(\x0b2\x1e.nakama.api.WriteStorageObje\
    ctR\x07objects\"\x82\x02\n\x1cWriteTournamentRecordRequest\x12#\n\rtourn\
    ament_id\x18\x01\x20\x01(\tR\x0ctournamentId\x12V\n\x06record\x18\x02\
    \x20\x01(\x0b2>.nakama.api.WriteTournamentRecordRequest.TournamentRecord\
    WriteR\x06record\x1ae\n\x15TournamentRecordWrite\x12\x14\n\x05score\x18\
    \x01\x20\x01(\x03R\x05score\x12\x1a\n\x08subscore\x18\x02\x20\x01(\x03R\
    \x08subscore\x12\x1a\n\x08metadata\x18\x03\x20\x01(\tR\x08metadataB=\n\
    \x19com.heroiclabs.nakama.apiB\tNakamaApiP\x01Z\x03api\xa2\x02\x04NKPB\
    \xaa\x02\x06Nakamab\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
